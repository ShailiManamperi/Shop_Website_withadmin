Index: adminBackend/Routes/mainRoutes.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import express from 'express';\r\nimport upload from \"../middlewares/upload.js\";\r\nimport db from '../utils/db.js';\r\nimport bwipjs from 'bwip-js';\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nconst router = express.Router();\r\n\r\n// Save  new item\r\nrouter.post(\"/add-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 }]), async (req, res) => {\r\n    try {\r\n        const { I_Id, I_name, descrip, color, price, warrantyPeriod, cost, material, s_Id, minQty, Ca_Id, sub_one, sub_two } = req.body;\r\n        const parsedPrice = parseFloat(price) || 0;\r\n        const parsedCost = parseFloat(cost) || 0;\r\n\r\n        // ✅ Check if main category exists\r\n        const [mainCatCheck] = await db.query(`SELECT name FROM Category WHERE Ca_Id = ?`, [Ca_Id]);\r\n        if (mainCatCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Main Category: ${Ca_Id}` });\r\n        }\r\n        const mainCategoryName = mainCatCheck[0].name;\r\n\r\n        // ✅ Check if subCat_one exists\r\n        const [subCatOneCheck] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n        if (subCatOneCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Sub Category One: ${sub_one}` });\r\n        }\r\n        const subCatOneName = subCatOneCheck[0].subcategory;\r\n\r\n        // ✅ Check if subCat_two exists or set as 'None'\r\n        let subCatTwoName = 'None';\r\n        if (sub_two !== 'None') {\r\n            const [subCatTwoCheck] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            if (subCatTwoCheck.length === 0) {\r\n                return res.status(400).json({ success: false, message: `Invalid Sub Category Two: ${sub_two}` });\r\n            }\r\n            subCatTwoName = subCatTwoCheck[0].subcategory;\r\n        }\r\n\r\n        // ✅ Check if supplier exists\r\n        const [supplierCheck] = await db.query(`SELECT s_ID FROM Supplier WHERE s_ID = ?`, [s_Id]);\r\n        if (supplierCheck.length === 0) {\r\n            return res.status(400).json({ success: false, message: `Invalid Supplier ID: ${s_Id}` });\r\n        }\r\n\r\n        // ✅ Extract image buffers (only main image required)\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        if (!imgBuffer) {\r\n            return res.status(400).json({ success: false, message: \"Main image (img) is required.\" });\r\n        }\r\n\r\n        // ✅ Insert into `Item` table\r\n        const itemSql = `\r\n            INSERT INTO Item (I_Id, I_name, descrip, color, material, price, stockQty, bookedQty, availableQty, minQTY, img, img1, img2, img3, warrantyPeriod, mn_Cat, sb_catOne, sb_catTwo)\r\n            VALUES (?, ?, ?, ?, ?, ?, 0, 0, 0, ?, ?, ?, ?, ?, ?, ?, ?, ?);\r\n        `;\r\n        await db.query(itemSql, [\r\n            I_Id,\r\n            I_name,\r\n            descrip,\r\n            color,\r\n            material,\r\n            parsedPrice,\r\n            minQty,\r\n            imgBuffer,\r\n            img1Buffer,\r\n            img2Buffer,\r\n            img3Buffer,\r\n            warrantyPeriod,\r\n            mainCategoryName,\r\n            subCatOneName,\r\n            subCatTwoName\r\n        ]);\r\n\r\n        // ✅ Insert into `Item_supplier` table\r\n        const supplierSql = `INSERT INTO item_supplier (I_Id, s_ID, unit_cost) VALUES (?, ?, ?);`;\r\n        await db.query(supplierSql, [I_Id, s_Id, parsedCost]);\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: \"✅ Item added successfully!\",\r\n            data: {\r\n                I_Id,\r\n                I_name,\r\n                descrip,\r\n                color,\r\n                material,\r\n                price: parsedPrice,\r\n                warrantyPeriod,\r\n                cost: parsedCost,\r\n                mn_Cat: mainCategoryName,\r\n                sb_catOne: subCatOneName,\r\n                sb_catTwo: subCatTwoName\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error inserting item data:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error inserting data into database\", details: err.message });\r\n    }\r\n});\r\n\r\n// Update item\r\nrouter.put(\"/update-item\", upload.fields([{ name: \"img\", maxCount: 1 }, { name: \"img1\", maxCount: 1 }, { name: \"img2\", maxCount: 1 }, { name: \"img3\", maxCount: 1 },]), async (req, res) => {\r\n    try {\r\n        const {I_Id, I_name, descrip, color, material, price, warrantyPeriod, stockQty, bookedQty, availableQty, maincategory, sub_one, sub_two, suppliers,} = req.body;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required.\" });\r\n        }\r\n\r\n        // ✅ Log received files and form data\r\n        const [itemCheckResult] = await db.query(`SELECT * FROM Item WHERE I_Id = ?`, [I_Id]);\r\n        if (itemCheckResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found.\" });\r\n        }\r\n\r\n        const parsedPrice = parseFloat(price) || 0;\r\n\r\n        // ✅ Properly extract image buffers\r\n        const imgBuffer = req.files[\"img\"]?.[0]?.buffer || null;\r\n        const img1Buffer = req.files[\"img1\"]?.[0]?.buffer || null;\r\n        const img2Buffer = req.files[\"img2\"]?.[0]?.buffer || null;\r\n        const img3Buffer = req.files[\"img3\"]?.[0]?.buffer || null;\r\n\r\n        // ✅ Fetch subcategory names\r\n        let subCatOneName = null;\r\n        let subCatTwoName = sub_two !== \"None\" ? null : \"None\";\r\n\r\n        if (sub_one) {\r\n            const [subOneResult] = await db.query(`SELECT subcategory FROM subCat_one WHERE sb_c_id = ?`, [sub_one]);\r\n            subCatOneName = subOneResult[0]?.subcategory || null;\r\n        }\r\n\r\n        if (sub_two !== \"None\") {\r\n            const [subTwoResult] = await db.query(`SELECT subcategory FROM subCat_two WHERE sb_cc_id = ?`, [sub_two]);\r\n            subCatTwoName = subTwoResult[0]?.subcategory || null;\r\n        }\r\n\r\n        let updateFields = [];\r\n        let updateValues = [];\r\n\r\n        // ✅ Dynamic field updates\r\n        const fields = {\r\n            I_name, descrip, color, material, price: parsedPrice, warrantyPeriod, stockQty, bookedQty, availableQty, mn_Cat: maincategory, sb_catOne: subCatOneName, sb_catTwo: subCatTwoName, img: imgBuffer, img1: img1Buffer, img2: img2Buffer, img3: img3Buffer,\r\n        };\r\n\r\n        for (const key in fields) {\r\n            if (fields[key] !== undefined && fields[key] !== null) {\r\n                updateFields.push(`${key} = ?`);\r\n                updateValues.push(fields[key]);\r\n            }\r\n        }\r\n\r\n        if (updateFields.length > 0) {\r\n            const updateQuery = `UPDATE Item SET ${updateFields.join(\", \")} WHERE I_Id = ?`;\r\n            updateValues.push(I_Id);\r\n            await db.query(updateQuery, updateValues);\r\n        }\r\n\r\n        // ✅ Handle suppliers\r\n        if (suppliers) {\r\n            let supplierData = typeof suppliers === \"string\" ? JSON.parse(suppliers) : suppliers;\r\n            if (Array.isArray(supplierData)) {\r\n                for (const { s_ID, unit_cost } of supplierData) {\r\n                    const parsedUnitCost = parseFloat(unit_cost) || 0;\r\n                    await db.query(\r\n                        `INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n                         VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)`,\r\n                        [I_Id, s_ID, parsedUnitCost]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            message: \"Item updated successfully\",\r\n            data: { I_Id, I_name },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"❌ Error updating item:\", err.message);\r\n        res.status(500).json({ success: false, message: \"Error updating item\", details: err.message });\r\n    }\r\n});\r\n\r\n// Save a order\r\nrouter.post(\"/orders\", async (req, res) => {\r\n    const {\r\n        FtName, SrName, address, balance, c_ID, category,newAddress,isAddressChanged, couponCode, deliveryPrice, discountAmount, district, dvStatus, email,\r\n        expectedDate, id, isNewCustomer, items, occupation, otherNumber, phoneNumber, specialNote, title, totalBillPrice, totalItemPrice,dvtype,\r\n        type, workPlace, t_name\r\n    } = req.body;\r\n\r\n    if (!items || !Array.isArray(items) || items.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Invalid or missing items.\" });\r\n    }\r\n\r\n    try {\r\n        let Cust_id = c_ID;\r\n        let Occupation = \"-\", WorkPlace = \"-\", tType = \"-\";\r\n        let stID = null;\r\n\r\n        if (type === 'Walking' || type === 'On site') {\r\n            Occupation = occupation;\r\n            WorkPlace = workPlace;\r\n        } else {\r\n            tType = t_name;\r\n        }\r\n\r\n        // **Handle New Customer Creation**\r\n        if (isNewCustomer) {\r\n            Cust_id = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n\r\n            const checkExistingCustomer = `SELECT c_ID FROM Customer WHERE email = ? OR contact1 = ? LIMIT 1`;\r\n            const [existingCustomer] = await db.query(checkExistingCustomer, [email, phoneNumber]);\r\n\r\n            if (existingCustomer.length > 0) {\r\n                return res.status(400).json({ success: false, message: \"Customer already exists.\" });\r\n            }\r\n\r\n            const sqlInsertCustomer = `\r\n                INSERT INTO Customer (c_ID, title, FtName, SrName, address, contact1, contact2, email, id, balance, type, category, t_name, occupation, workPlace)\r\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n\r\n            const valuesCustomer = [\r\n                Cust_id, title, FtName, SrName, address, phoneNumber, otherNumber || \"\", email, id, 0, type, category, tType, Occupation, WorkPlace\r\n            ];\r\n\r\n            await db.query(sqlInsertCustomer, valuesCustomer);\r\n        }\r\n\r\n        // **Calculate Net Total and Balance**\r\n        const netTotal = parseFloat(totalBillPrice) || 0;\r\n        const advance = 0;\r\n        const balance = netTotal - advance;\r\n\r\n        // **Generate Order ID**\r\n        const orID = `ORD_${Date.now()}`;\r\n        const orderDate = new Date().toISOString().split(\"T\")[0];\r\n\r\n        // **Handle Coupon Code**\r\n        if (couponCode) {\r\n            const couponQuery = `SELECT stID FROM sales_coupon WHERE cpID = ?`;\r\n            const [couponResult] = await db.query(couponQuery, [couponCode]);\r\n\r\n            if (couponResult.length === 0) {\r\n                return res.status(400).json({ success: false, message: \"Invalid coupon code.\" });\r\n            }\r\n\r\n            stID = couponResult[0].stID;\r\n            const newTotalOrder = parseFloat(totalItemPrice);\r\n            const updateSalesTeamQuery = `UPDATE sales_team SET totalOrder = totalOrder + ? WHERE stID = ?`;\r\n            await db.query(updateSalesTeamQuery, [newTotalOrder, stID]);\r\n        }\r\n\r\n        // **Insert Order**\r\n        const orderQuery = `\r\n            INSERT INTO Orders (OrID, orDate, c_ID, orStatus, delStatus, delPrice, discount, netTotal, total, stID, expectedDate, specialNote, ordertype, advance, balance, payStatus)\r\n            VALUES (?, ?, ?, 'Pending', ?, ?, ?, ?, ?, ?, ?, ?, 'on-site', ?, ?, 'Pending')`;\r\n\r\n        const orderParams = [\r\n            orID, orderDate, Cust_id, dvStatus, parseFloat(deliveryPrice) || 0, parseFloat(discountAmount) || 0,\r\n            parseFloat(totalItemPrice) || 0, parseFloat(totalBillPrice) || 0, stID, expectedDate, specialNote, advance, balance\r\n        ];\r\n\r\n        await db.query(orderQuery, orderParams);\r\n\r\n        // **Insert Order Details (Bulk Insert)**\r\n        const orderDetailValues = items.map(item => [\r\n            orID, item.I_Id, item.qty, parseFloat(item.price)\r\n        ]);\r\n\r\n        const orderDetailQuery = `\r\n            INSERT INTO Order_Detail (orID, I_Id, qty, tprice) VALUES ?`;\r\n\r\n        await db.query(orderDetailQuery, [orderDetailValues]);\r\n\r\n        // **Insert Delivery Info**\r\n        if (dvStatus === \"Delivery\" && !isAddressChanged) {\r\n            const dvID = `DLV_${Date.now()}`;\r\n            const deliveryQuery = `\r\n                INSERT INTO delivery (dv_id, orID, address, district, c_ID, status, schedule_Date,type)\r\n                VALUES (?, ?, ?, ?, ?, 'Pending', ?,?)`;\r\n\r\n            await db.query(deliveryQuery, [dvID, orID, address, district, Cust_id, expectedDate,dvtype]);\r\n        }else if (dvStatus === \"Delivery\" && isAddressChanged){\r\n            const dvID = `DLV_${Date.now()}`;\r\n            const deliveryQuery = `\r\n                INSERT INTO delivery (dv_id, orID, address, district, c_ID, status, schedule_Date,type)\r\n                VALUES (?, ?, ?, ?, ?, 'Pending', ?,?)`;\r\n\r\n            await db.query(deliveryQuery, [dvID, orID, newAddress, district, Cust_id, expectedDate,dvtype]);\r\n        }\r\n\r\n        // **Insert Coupon Info**\r\n        if (couponCode) {\r\n            const ocID = `OCP_${Date.now()}`;\r\n            const couponQuery = `INSERT INTO order_coupon (ocID, orID, cpID) VALUES (?, ?, ?)`;\r\n            await db.query(couponQuery, [ocID, orID, couponCode]);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Order placed successfully\",\r\n            data: { orID, orderDate, expectedDate }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error inserting order data:\", error);\r\n\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get all orders\r\nrouter.get(\"/orders\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders\");\r\n\r\n        // If no promotions found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Orders found\" });\r\n        }\r\n\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID : order.OrID, // Assuming you have an id column\r\n            orDate : order.orDate,\r\n            customer : order.c_ID,\r\n            ordertype : order.ordertype,\r\n            orStatus : order.orStatus,\r\n            delStatus : order.delStatus,\r\n            delPrice : order.delPrice,\r\n            disPrice : order.discount,\r\n            totPrice : order.total,\r\n            advance : order.advance,\r\n            balance : order.balance,\r\n            payStatus : order.payStatus,\r\n            stID:  order.stID,\r\n            expectedDeliveryDate: order.expectedDate\r\n        }));\r\n        // console.log(formattedOrders);\r\n\r\n        // Send the formatted promotions as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Orders are founded.\",\r\n            data : formattedOrders,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching promotions:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching promotions\" });\r\n    }\r\n});\r\n\r\n// Get all items\r\nrouter.get(\"/allitems\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [items] = await db.query(\"SELECT * FROM Item\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id, // Item ID\r\n            I_name: item.I_name, // Item name\r\n            descrip: item.descrip, // Item description\r\n            price: item.price, // Price\r\n            stockQty: item.stockQty, // Quantity\r\n            availableQty : item.availableQty, // available stock\r\n            warrantyPeriod: item.warrantyPeriod,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert LONGBLOB image to Base64\r\n            color: item.color,\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// Get all customers with filters for balance conditions\r\nrouter.get(\"/allcustomers\", async (req, res) => {\r\n    try {\r\n        const { filter } = req.query; // Get filter type from query params\r\n        let query = \"SELECT * FROM Customer\";\r\n\r\n        // Apply filters based on balance conditions\r\n        if (filter === \"Cash\") {\r\n            query += \" WHERE category = 'Cash'\";\r\n        } else if (filter === \"Credit\") {\r\n            query += \" WHERE category = 'Credit'\";\r\n        } else if (filter === \"Loyal\") {\r\n            query += \" WHERE category = 'Loyal'\";\r\n        }\r\n\r\n        const [customers] = await db.query(query);\r\n\r\n        // If no customers found, return a 404 status\r\n        if (customers.length === 0) {\r\n            return res.status(404).json({ message: \"No customers found\" });\r\n        }\r\n\r\n        // Format the customer data\r\n        const formattedCustomers = customers.map(customer => ({\r\n            c_ID: customer.c_ID, // Customer ID\r\n            title: customer.title,\r\n            FtName: customer.FtName,\r\n            SrName: customer.SrName,\r\n            id: customer.id, // NIC or identifier\r\n            email: customer.email || \"\", // Email (nullable)\r\n            address: customer.address, // Address\r\n            contact1: customer.contact1, // Primary contact\r\n            contact2: customer.contact2 || \"\", // Secondary contact (nullable)\r\n            balance: customer.balance, // Account balance\r\n            category: customer.category,\r\n            type: customer.type,\r\n            t_name: customer.t_name,\r\n            occupation: customer.occupation,\r\n            workPlace: customer.workPlace,\r\n        }));\r\n        // Send the formatted customers as a JSON response\r\n        return res.status(200).json(formattedCustomers);\r\n    } catch (error) {\r\n        console.error(\"Error fetching customers:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching customers\" });\r\n    }\r\n});\r\n\r\n// Get all delivery notes\r\nrouter.get(\"/alldeliverynotes\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveryNotes] = await db.query(\"SELECT * FROM delivery_note\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveryNotes.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveryNotes = deliveryNotes.map(deliverynote => ({\r\n            delNoID: deliverynote.delNoID,\r\n            driverName: deliverynote.driverName,\r\n            date: deliverynote.date,\r\n            district: deliverynote.district\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveryNotes);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n// Get all deliveries\r\nrouter.get(\"/alldeliveries\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all items\r\n        const [deliveries] = await db.query(\"SELECT * FROM delivery\");\r\n\r\n        // If no items found, return a 404 status\r\n        if (deliveries.length === 0) {\r\n            return res.status(404).json({ message: \"No deliveries found\" });\r\n        }\r\n\r\n        // Format the items data\r\n        const formattedDeliveries = deliveries.map(delivery => ({\r\n            dv_id: delivery.dv_id,\r\n            orID: delivery.orID,\r\n            district: delivery.district,\r\n            status: delivery.status,\r\n            schedule_Date: formatDate(delivery.schedule_Date),\r\n            delivery_Date: formatDate(delivery.delivery_Date),\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedDeliveries);\r\n    } catch (error) {\r\n        console.error(\"Error fetching deliveries:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching deliveries\" });\r\n    }\r\n});\r\n\r\n//add a new supplier\r\nrouter.post(\"/supplier\", async (req, res) => {\r\n    const { name, contact, contact2, address} = req.body;\r\n\r\n    // Generate new supplier ID\r\n    const s_ID = await generateNewId(\"supplier\", \"s_ID\", \"S\");\r\n    const sqlInsertSupplier = `\r\n        INSERT INTO Supplier (s_ID, name, address, contact, contact2)\r\n        VALUES (?, ?, ?, ?, ?)`;\r\n    const valuesSupplier = [\r\n        s_ID,\r\n        name,\r\n        address,\r\n        contact,\r\n        contact2 || \"\", // If contact2 is empty, set it as an empty string\r\n    ];\r\n\r\n    try {\r\n        // Insert the supplier into the Supplier table\r\n        await db.query(sqlInsertSupplier, valuesSupplier);\r\n\r\n        // Respond with success message and new supplier details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Supplier  added successfully\",\r\n            data: {\r\n                s_ID,\r\n                name,\r\n                contact,\r\n                contact2,\r\n                address,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting supplier  data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//add a new customer\r\nrouter.post(\"/customer\", async (req, res) => {\r\n    const {title,FtName,SrName,id , email, contact, contact2, address,type,category,t_name,occupation,workPlace} = req.body;\r\n\r\n    // Generate new supplier ID\r\n    const c_ID = await generateNewId(\"Customer\", \"c_ID\", \"Cus\");\r\n    console.log(c_ID);\r\n    const sqlInsertCustomer = `\r\n        INSERT INTO Customer (c_ID,title,FtName,SrName, address, contact1, contact2,email,id,balance,type,category,t_name,occupation,workPlace) VALUES \r\n                    (?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?)`;\r\n    const valuesCustomer = [\r\n        c_ID,title, FtName,SrName,address, contact, contact2 || \"\", email,id ,0,type,category,t_name,occupation,workPlace\r\n    ];\r\n\r\n    try {\r\n        // Insert the customer into the Customer table\r\n        await db.query(sqlInsertCustomer, valuesCustomer);\r\n\r\n        // Respond with success message and new supplier details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Customer  added successfully\",\r\n            data: {\r\n                c_ID,\r\n                FtName,\r\n                contact,\r\n                contact2,\r\n                id,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting customer  data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one accept order in-detail\r\nrouter.get(\"/accept-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Customer and Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, c.title, c.FtName, c.SrName, c.address, c.contact1, c.contact2,\r\n                o.advance, o.balance, o.payStatus, o.orStatus, o.delStatus, o.delPrice, o.discount, o.total,\r\n                o.ordertype, o.expectedDate, o.specialNote, s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Booked Items\r\n        const bookedItemsQuery = `\r\n            SELECT bi.I_Id, i.I_name, bi.qty\r\n            FROM booked_item bi\r\n                     JOIN Item i ON bi.I_Id = i.I_Id\r\n            WHERE bi.orID = ?`;\r\n\r\n        const [bookedItemsResult] = await db.query(bookedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Fetch Accepted Orders\r\n        const acceptedOrdersQuery = `\r\n            SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n            FROM accept_orders ao\r\n                     JOIN Item i ON ao.I_Id = i.I_Id\r\n            WHERE ao.orID = ?`;\r\n\r\n        const [acceptedOrdersResult] = await db.query(acceptedOrdersQuery, [orID]);\r\n\r\n        // 5\uFE0F⃣ Format Customer Name with Title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 6\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate:formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID,\r\n            customerName: customerName,\r\n            address: orderData.address,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                color: item.color,\r\n                quantity: item.qty,\r\n                unitPrice: item.unitPrice,\r\n                totalPrice: item.tprice,\r\n                booked: item.bookedQty > 0,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty,\r\n                stockQuantity: item.stockQty\r\n            })),\r\n            bookedItems: bookedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                quantity: item.qty\r\n            })),\r\n            acceptedOrders: acceptedOrdersResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                itemReceived: item.itemReceived,\r\n                status: item.status\r\n            }))\r\n        };\r\n\r\n        // 7\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, status, schedule_Date, delivery_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Get Details of isssued order\r\nrouter.get(\"/issued-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Customer and Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.advance, o.balance, o.payStatus,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype, o.stID,\r\n                o.expectedDate, o.specialNote, c.title, c.FtName, c.SrName, c.address,\r\n                s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Issued Items for this Order from `m_s_r_detail`\r\n        const issuedItemsQuery = `\r\n            SELECT\r\n                m.I_Id, i.I_name, m.stock_Id, m.sr_ID, m.barcode, m.status, m.datetime\r\n            FROM m_s_r_detail m\r\n                     JOIN Item i ON m.I_Id = i.I_Id\r\n            WHERE m.orID = ?`;\r\n\r\n        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Format Customer Name with Title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 5\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate:formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID,\r\n            customerName: customerName, // Title added to customer name\r\n            address: orderData.address,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                color: item.color,\r\n                quantity: item.qty,\r\n                unitPrice: item.unitPrice,\r\n                totalPrice: item.tprice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty\r\n            })),\r\n            issuedItems: issuedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                stockId: item.stock_Id,\r\n                srID: item.sr_ID,\r\n                barcode: item.barcode.toString('base64'), // Convert to readable format if needed\r\n                status: item.status,\r\n                datetime: item.datetime\r\n            }))\r\n        };\r\n\r\n        // 6\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: new Date(deliveryData.schedule_Date).toISOString().split(\"T\")[0],\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null,\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Get Details of returned orders\r\nrouter.get(\"/returned-order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // 1\uFE0F⃣ Fetch Order Info with Customer and Sales Team Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.customerEmail, o.contact1, o.contact2, o.advance, o.balance, o.payStatus,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.total, o.ordertype, o.stID,\r\n                o.expectedDate, o.specialNote, c.title, c.FtName, c.SrName, c.address,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                ro.detail AS returnReason  -- Fetch return reason if available\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID -- Join return_orders table\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n        const orderData = orderResult[0];\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        // 3\uFE0F⃣ Fetch Issued Items for this Order from `m_s_r_detail`\r\n        const issuedItemsQuery = `\r\n            SELECT\r\n                m.I_Id, i.I_name, m.stock_Id, m.sr_ID, m.barcode, m.status, m.datetime\r\n            FROM m_s_r_detail m\r\n                     JOIN Item i ON m.I_Id = i.I_Id\r\n            WHERE m.orID = ?`;\r\n\r\n        const [issuedItemsResult] = await db.query(issuedItemsQuery, [orID]);\r\n\r\n        // 4\uFE0F⃣ Format Customer Name with Title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // 5\uFE0F⃣ Initialize Response Object\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate: formatDate(orderData.orDate),\r\n            customerId: orderData.c_ID,\r\n            customerName: customerName, // Title added to customer name\r\n            address: orderData.address,\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            returnReason: orderData.returnReason || null, // Include return reason if available\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                color: item.color,\r\n                quantity: item.qty,\r\n                unitPrice: item.unitPrice,\r\n                totalPrice: item.tprice,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty\r\n            })),\r\n            issuedItems: issuedItemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                stockId: item.stock_Id,\r\n                srID: item.sr_ID,\r\n                barcode: item.barcode.toString('base64'), // Convert to readable format if needed\r\n                status: item.status,\r\n                datetime: item.datetime\r\n            }))\r\n        };\r\n\r\n        // 6\uFE0F⃣ Fetch Delivery Info If Order is for Delivery\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, contact, status, schedule_Date\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Returned order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching returned order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get one order in-detail\r\nrouter.get(\"/order-details\", async (req, res) => {\r\n    try {\r\n        const { orID } = req.query;\r\n        if (!orID) {\r\n            return res.status(400).json({ success: false, message: \"Order ID is required\" });\r\n        }\r\n\r\n        // Fetch Order Info along with Customer and Sales Team details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, c.title, c.FtName, c.SrName, c.address, c.contact1, c.contact2,\r\n                o.orStatus, o.delStatus, o.delPrice, o.discount, o.netTotal, o.total,\r\n                o.advance, o.balance, o.payStatus, o.expectedDate, o.specialNote, o.ordertype,\r\n                s.stID, e.name AS salesEmployeeName\r\n            FROM Orders o\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            WHERE o.OrID = ?`;\r\n\r\n        const [orderResult] = await db.query(orderQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        const orderData = orderResult[0];\r\n\r\n        // Fetch Ordered Items\r\n        const itemsQuery = `\r\n            SELECT\r\n                od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                i.bookedQty, i.availableQty, i.stockQty\r\n            FROM Order_Detail od\r\n                     JOIN Item i ON od.I_Id = i.I_Id\r\n            WHERE od.orID = ?`;\r\n\r\n        const [itemsResult] = await db.query(itemsQuery, [orID]);\r\n\r\n        console.log(\"view \"+orderData.expectedDate);\r\n        // Format customer name with title\r\n        const customerName = [orderData.title, orderData.FtName, orderData.SrName].filter(Boolean).join(\" \");\r\n\r\n        // Prepare Order Response\r\n        const orderResponse = {\r\n            orderId: orderData.OrID,\r\n            orderDate:  formatDate(orderData.orDate),\r\n            ordertype: orderData.ordertype,\r\n            phoneNumber: orderData.contact1,\r\n            optionalNumber: orderData.contact2,\r\n            orderStatus: orderData.orStatus,\r\n            deliveryStatus: orderData.delStatus,\r\n            deliveryCharge: orderData.delPrice,\r\n            discount: orderData.discount,\r\n            netTotal: orderData.netTotal,\r\n            totalPrice: orderData.total,\r\n            advance: orderData.advance,\r\n            balance: orderData.balance,\r\n            payStatus: orderData.payStatus,\r\n            customerId: orderData.c_ID,\r\n            name: customerName, // Title added to the name\r\n            address: orderData.address,\r\n            expectedDeliveryDate: formatDate(orderData.expectedDate),\r\n            specialNote: orderData.specialNote,\r\n            salesTeam: orderData.salesEmployeeName ? { employeeName: orderData.salesEmployeeName } : null,\r\n            items: itemsResult.map(item => ({\r\n                itemId: item.I_Id,\r\n                itemName: item.I_name,\r\n                color: item.color,\r\n                quantity: item.qty,\r\n                unitPrice: item.unitPrice,\r\n                totalPrice: item.tprice,\r\n                booked: item.bookedQty > 0,\r\n                bookedQuantity: item.bookedQty,\r\n                availableQuantity: item.availableQty,\r\n                stockQuantity: item.stockQty,\r\n            })),\r\n        };\r\n\r\n        // Fetch Delivery Info if it's a delivery order\r\n        if (orderData.delStatus === \"Delivery\") {\r\n            const deliveryQuery = `\r\n                SELECT dv_id, address, district, status, schedule_Date, delivery_Date, c_ID\r\n                FROM delivery\r\n                WHERE orID = ?`;\r\n\r\n            const [deliveryResult] = await db.query(deliveryQuery, [orID]);\r\n\r\n            if (deliveryResult.length > 0) {\r\n                const deliveryData = deliveryResult[0];\r\n                orderResponse.deliveryInfo = {\r\n                    deliveryId: deliveryData.dv_id,\r\n                    address: deliveryData.address,\r\n                    district: deliveryData.district,\r\n                    status: deliveryData.status,\r\n                    scheduleDate: formatDate(deliveryData.schedule_Date),\r\n                    deliveryDate: deliveryData.delivery_Date ? formatDate(deliveryData.delivery_Date) : null\r\n\r\n                };\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order details fetched successfully\",\r\n            order: orderResponse\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching order details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching order details\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET Item Details by Item ID\r\nrouter.get(\"/item-details\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // ✅ Fetch item details from Item table\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty, I.bookedQty, I.availableQty, I.minQTY,\r\n                I.warrantyPeriod, I.img, I.img1, I.img2, I.img3, I.color, I.material, I.mn_Cat, I.sb_catOne, I.sb_catTwo\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [I_Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData = itemResult[0];\r\n\r\n        // ✅ Convert images to Base64\r\n        const mainImgBase64 = itemData.img ? Buffer.from(itemData.img).toString(\"base64\") : null;\r\n        const img1Base64 = itemData.img1 ? Buffer.from(itemData.img1).toString(\"base64\") : null;\r\n        const img2Base64 = itemData.img2 ? Buffer.from(itemData.img2).toString(\"base64\") : null;\r\n        const img3Base64 = itemData.img3 ? Buffer.from(itemData.img3).toString(\"base64\") : null;\r\n\r\n        // ✅ Fetch suppliers providing this item\r\n        const supplierQuery = `\r\n            SELECT S.s_ID, S.name, S.contact, ISUP.unit_cost\r\n            FROM Supplier S\r\n                     JOIN item_supplier ISUP ON S.s_ID = ISUP.s_ID\r\n            WHERE ISUP.I_Id = ?`;\r\n\r\n        const [suppliersResult] = await db.query(supplierQuery, [I_Id]);\r\n\r\n        const suppliers = suppliersResult.map(supplier => ({\r\n            s_ID: supplier.s_ID,\r\n            name: supplier.name,\r\n            contact: supplier.contact,\r\n            unit_cost: supplier.unit_cost\r\n        }));\r\n\r\n        // ✅ Fetch stock details **excluding** 'Issued' status, only include 'Available', 'Damage', 'Reserved'\r\n        const stockQuery = `\r\n            SELECT srd_Id, stock_Id, sr_ID, status\r\n            FROM m_s_r_detail\r\n            WHERE I_Id = ?\r\n              AND status IN ('Available', 'Damage', 'Reserved')\r\n            ORDER BY srd_Id ASC , FIELD(status, 'Available', 'Reserved', 'Damage')`;\r\n\r\n        const [stockResults] = await db.query(stockQuery, [I_Id]);\r\n        console.log(I_Id);\r\n\r\n        const stockDetails = stockResults.map(stock => ({\r\n            srd_Id: stock.srd_Id,\r\n            stock_Id: stock.stock_Id,\r\n            sr_ID: stock.sr_ID,\r\n            status: stock.status\r\n        }));\r\n        console.log(stockDetails);\r\n\r\n        // ✅ Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData.I_Id,\r\n                I_name: itemData.I_name,\r\n                descrip: itemData.descrip,\r\n                color: itemData.color,\r\n                material: itemData.material,\r\n                price: itemData.price,\r\n                stockQty: itemData.stockQty,\r\n                availableQty: itemData.availableQty,\r\n                bookedQty: itemData.bookedQty,\r\n                warrantyPeriod: itemData.warrantyPeriod,\r\n                minQTY: itemData.minQTY,\r\n                maincategory: itemData.mn_Cat,\r\n                sub_one: itemData.sb_catOne,\r\n                sub_two: itemData.sb_catTwo,\r\n                img: mainImgBase64,\r\n                img1: img1Base64,\r\n                img2: img2Base64,\r\n                img3: img3Base64,\r\n                suppliers: suppliers,\r\n                stockDetails: stockDetails // Only 'Available', 'Reserved', 'Damage'\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= pending\r\nrouter.get(\"/orders-pending\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [orders] = await db.query(\"SELECT * FROM Orders WHERE orStatus = 'pending'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No pending orders found\" });\r\n        }\r\n\r\n        // console.log(\"table \"+order.expectedDate);\r\n\r\n        // Format orders\r\n        const formattedOrders = orders.map(order => ({\r\n            OrID: order.OrID, // Order ID\r\n            orDate: order.orDate, // Order Date\r\n            customer: order.c_ID, // Customer Email\r\n            ordertype : order.ordertype,\r\n            orStatus: order.orStatus, // Order Status\r\n            dvStatus: order.delStatus, // Delivery Status\r\n            dvPrice: order.delPrice, // Delivery Price\r\n            disPrice: order.discount, // Discount Price\r\n            totPrice: order.total, // Total Price\r\n            advance: order.advance,\r\n            balance: order.balance,\r\n            payStatus : order.payStatus,\r\n            stID: order.stID, // Sales Team ID\r\n            expectedDeliveryDate: order.expectedDate, // Expected Delivery Date\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= accepting\r\nrouter.get(\"/orders-accepting\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= completed\r\nrouter.get(\"/orders-completed\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Completed'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch Issued order\r\nrouter.get(\"/orders-issued\", async (req, res) => {\r\n    try {\r\n        // Query to fetch orders with their acceptance status from accept_orders table\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Issued'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Completed orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Completed orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching completed orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch Returned order\r\nrouter.get(\"/orders-returned\", async (req, res) => {\r\n    try {\r\n        // Query to fetch returned orders with their acceptance status and return reason\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n            WHERE o.orStatus = 'Returned'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No returned orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Returned orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching returned orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch Canceled order\r\nrouter.get(\"/orders-canceled\", async (req, res) => {\r\n    try {\r\n        // Query to fetch returned orders with their acceptance status and return reason\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived, ao.status AS acceptanceStatus,\r\n                ro.detail AS returnReason\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n                     LEFT JOIN return_orders ro ON o.OrID = ro.OrID\r\n            WHERE o.orStatus = 'Cancelled'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        // If no orders found, return a 404 status\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No returned orders found\" });\r\n        }\r\n\r\n        // Group orders by OrID\r\n        const groupedOrders = {};\r\n\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    itemReceived: order.itemReceived,\r\n                    returnReason: order.returnReason || \"No reason provided\", // Handle null reasons\r\n                    acceptanceStatus: \"Complete\", // Default status is Complete\r\n                    acceptanceStatuses: [] // Track individual item statuses\r\n                };\r\n            }\r\n\r\n            // Add each item status to the list\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            // If any items have an \"In Production\" or \"None\" status, mark as \"Incomplete\"\r\n            if (order.acceptanceStatus === \"In Production\" || order.acceptanceStatus === \"None\") {\r\n                groupedOrders[order.OrID].acceptanceStatus = \"Incomplete\";\r\n            }\r\n        });\r\n\r\n        // Convert the grouped orders into an array\r\n        const formattedOrders = Object.values(groupedOrders);\r\n\r\n        // Send the formatted orders with their acceptance status as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Returned orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching returned orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching returned orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all orders by status= inproduction\r\nrouter.get(\"/orders-inproduction\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all pending Orders\r\n        const [suporders] = await db.query(\"SELECT * FROM production WHERE status= 'Incomplete'\");\r\n\r\n        // If no orders found, return a 404 status\r\n        if (suporders.length === 0) {\r\n            return res.status(404).json({ message: \"No supplier orders found\" });\r\n        }\r\n\r\n        // Format orders\r\n        const formattedOrders = suporders.map(order => ({\r\n            p_ID : order.p_ID,\r\n            I_Id : order.I_Id,\r\n            qty : order.qty,\r\n            s_ID : order.s_ID,\r\n            expectedDate : order.expectedDate,\r\n            specialNote: order.specialNote,\r\n            status: order.status\r\n        }));\r\n\r\n        // Send the formatted orders as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Pending orders found.\",\r\n            data: formattedOrders,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching pending orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching pending orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all items where stock count is less than or equal to one\r\nrouter.get(\"/allitemslessone\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch items with qty <= 1\r\n        const [items] = await db.query(\r\n            \"SELECT I_Id, I_name, descrip, price,stockQty, availableQty, img FROM Item WHERE availableQty <= minQTY\"\r\n        );\r\n\r\n        // If no items found, return a 404 status with a descriptive message\r\n        if (items.length === 0) {\r\n            return res.status(404).json({ message: \"No items found with stock count less than or equal to 1\" });\r\n        }\r\n\r\n        // Format the items data with necessary fields\r\n        const formattedItems = items.map(item => ({\r\n            I_Id: item.I_Id,\r\n            I_name: item.I_name,\r\n            descrip: item.descrip,\r\n            price: item.price,\r\n            availableQty: item.availableQty,\r\n            stockQty: item.stockQty,\r\n            img: `data:image/png;base64,${item.img.toString(\"base64\")}`, // Convert image to base64\r\n        }));\r\n\r\n        // Send the formatted items as a JSON response\r\n        return res.status(200).json(formattedItems);\r\n    } catch (error) {\r\n        console.error(\"Error fetching items:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching items\" });\r\n    }\r\n});\r\n\r\n// get all suppliers for the item\r\nrouter.get(\"/item-suppliers\", async (req, res) => {\r\n    try {\r\n        const { I_Id } = req.query;\r\n\r\n        // Validate the input\r\n        if (!I_Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch the suppliers associated with the item from item_supplier table\r\n        const itemSuppliersQuery = `\r\n            SELECT s_ID\r\n            FROM item_supplier\r\n            WHERE I_Id = ?`;\r\n\r\n        const [itemSuppliersResult] = await db.query(itemSuppliersQuery, [I_Id]);\r\n\r\n        if (itemSuppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found for the given item\" });\r\n        }\r\n\r\n        // Step 2: Extract the supplier IDs from the result\r\n        const supplierIds = itemSuppliersResult.map(row => row.s_ID);\r\n\r\n        // Step 3: Fetch the supplier details using the supplier IDs\r\n        const suppliersQuery = `\r\n            SELECT s_ID, name, contact\r\n            FROM Supplier\r\n            WHERE s_ID IN (?)`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery, [supplierIds]);\r\n\r\n        // Step 4: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get all items for the supplier\r\nrouter.get(\"/supplier-items\", async (req, res) => {\r\n    try {\r\n        const { s_Id } = req.query;\r\n\r\n        // Validate input\r\n        if (!s_Id) {\r\n            return res.status(400).json({ success: false, message: \"Supplier ID is required\" });\r\n        }\r\n\r\n        // Query to fetch supplier's items along with cost, warranty period, and image\r\n        const query = `\r\n            SELECT\r\n                item_supplier.I_Id,\r\n                Item.I_name,\r\n                item_supplier.unit_cost,\r\n                Item.warrantyPeriod,\r\n                Item.img  -- Fetch the binary image (LONGBLOB)\r\n            FROM item_supplier\r\n                     JOIN Item ON Item.I_Id = item_supplier.I_Id\r\n            WHERE item_supplier.s_ID = ?\r\n        `;\r\n\r\n        const [itemsResult] = await db.query(query, [s_Id]);\r\n\r\n        // If no items found, return a 404 response\r\n        if (itemsResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No items found for the given supplier\" });\r\n        }\r\n\r\n        // Convert image binary data to Base64\r\n        const itemsWithImages = itemsResult.map(item => ({\r\n            ...item,\r\n            img: item.img ? `data:image/jpeg;base64,${item.img.toString('base64')}` : null  // Convert LONGBLOB to Base64\r\n        }));\r\n\r\n        // Return the supplier's items with cost, warranty period, and image\r\n        return res.status(200).json({\r\n            success: true,\r\n            items: itemsWithImages,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching supplier items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Get all suppliers\r\nrouter.get(\"/suppliers\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all suppliers\r\n        const suppliersQuery = `SELECT s_ID, name, contact,contact2,address FROM Supplier`;\r\n\r\n        const [suppliersResult] = await db.query(suppliersQuery);\r\n        // Step 2: Check if suppliers were found\r\n        if (suppliersResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No suppliers found\" });\r\n        }\r\n\r\n        // Step 3: Return the supplier details\r\n        return res.status(200).json({\r\n            success: true,\r\n            suppliers: suppliersResult,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching suppliers:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// get item detail in item table only\r\nrouter.get(\"/item-detail\", async (req, res) => {\r\n    try {\r\n        const { Id } = req.query;\r\n\r\n        if (!Id) {\r\n            return res.status(400).json({ success: false, message: \"Item ID is required\" });\r\n        }\r\n\r\n        // Step 1: Fetch Item details\r\n        const itemQuery = `\r\n            SELECT\r\n                I.I_Id, I.I_name, I.descrip, I.price, I.stockQty,I.bookedQty,I.availableQty,\r\n                I.warrantyPeriod, I.img\r\n            FROM Item I\r\n            WHERE I.I_Id = ?`;\r\n\r\n        const [itemResult] = await db.query(itemQuery, [Id]);\r\n\r\n        if (itemResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Item not found\" });\r\n        }\r\n\r\n        const itemData1 = itemResult[0];\r\n        // Step 2: Construct final response\r\n        const responseData = {\r\n            success: true,\r\n            item: {\r\n                I_Id: itemData1.I_Id,\r\n                I_name: itemData1.I_name,\r\n                price: itemData1.price,\r\n                stockQty: itemData1.stockQty,\r\n                bookedQty: itemData1.bookedQty,\r\n                availableQty: itemData1.availableQty,\r\n            }\r\n        };\r\n\r\n        return res.status(200).json(responseData);\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching item details:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// save in production\r\nrouter.post('/add-production', async (req, res) => {\r\n    const {itemId, qty, supplierId, expectedDate, specialnote} = req.body;\r\n\r\n    if (!itemId || !qty || !supplierId || !expectedDate) {\r\n        return res.status(400).json({error: 'All fields are required'});\r\n    }\r\n\r\n    const p_ID = `InP_${Date.now()}`;\r\n\r\n    const sql = `INSERT INTO production (p_ID, I_Id, qty, s_ID, expectedDate, specialNote,status)\r\n                 VALUES (?, ?, ?, ?, ?, ?,'Incomplete')`;\r\n    const [Result] = await db.query(sql, [p_ID, itemId, qty, supplierId, expectedDate, specialnote]);\r\n    return res.status(200).json({\r\n        success: true,\r\n        message: \"Order details fetched successfully\",\r\n        result: Result\r\n    });\r\n});\r\n\r\n// Get category namees\r\nrouter.get(\"/getcategory\", async (req, res) => {\r\n    const { category } = req.query;\r\n\r\n    // Check if category is provided\r\n    if (!category) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category is required\",\r\n        });\r\n    }\r\n\r\n    // SQL query to join Category and subCat_one based on category name\r\n    const sql = `\r\n        SELECT sc.sb_c_id, sc.subcategory, sc.img, c.name AS category\r\n        FROM subCat_one sc\r\n                 INNER JOIN Category c ON sc.Ca_Id = c.Ca_Id\r\n        WHERE c.name = ?\r\n    `;\r\n\r\n    try {\r\n        const [rows] = await db.query(sql, [category]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No images found for the given category\",\r\n            });\r\n        }\r\n\r\n        // Send back the response with image data\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Category images retrieved successfully\",\r\n            data: rows.map(row => ({\r\n                id: row.sb_c_id,\r\n                category: row.category,\r\n                subcategory: row.subcategory,\r\n                img: row.img.toString(\"base64\"), // Convert binary image to Base64\r\n            })),\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Update stock\r\nrouter.post(\"/update-stock\", upload.single(\"image\"), async (req, res) => {\r\n    const { p_ID, rDate, recCount, cost, detail } = req.body;\r\n    const imageFile = req.file;\r\n\r\n    if (!p_ID || !rDate || !recCount) {\r\n        return res.status(400).json({ error: \"All fields are required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch current quantity and item details from production\r\n        const [rows] = await db.query(\"SELECT qty, I_Id, s_ID FROM production WHERE p_ID = ?\", [p_ID]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({ error: \"Production order not found\" });\r\n        }\r\n\r\n        const currentQty = rows[0].qty;\r\n        const itemId = rows[0].I_Id;\r\n        const supId = rows[0].s_ID;\r\n        const receivedQty = parseInt(recCount, 10);\r\n\r\n        // Validate that the item exists in the `item` table\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM item WHERE I_Id = ?\", [itemId]);\r\n\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ error: \"Item ID does not exist in item table\" });\r\n        }\r\n\r\n        console.log(\"Validated Item ID:\", itemId);\r\n\r\n        // Handle image upload\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${itemId}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Insert into main_stock_received\r\n        const insertQuery = `\r\n            INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count, unitPrice, detail)\r\n            VALUES (?, ?, ?, ?, ?, ?)`;\r\n        const [result] = await db.query(insertQuery, [supId, itemId, rDate, receivedQty, cost, detail || \"\"]);\r\n        console.log(result);\r\n        const receivedStockId = result.insertId;\r\n        console.log(receivedStockId);\r\n\r\n        // Fetch last stock_Id for this item\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM m_s_r_detail WHERE I_Id = ?`,\r\n            [itemId]\r\n        );\r\n\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        const insertDetailQuery = `\r\n            INSERT INTO m_s_r_detail (I_Id, stock_Id, sr_ID, barcode,status,orID,datetime)\r\n            VALUES (?, ?, ?, ?,'Available','','')`;\r\n        console.log(insertDetailQuery);\r\n\r\n        // Ensure barcode folder exists\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        // Ensure `stockCount` is properly defined\r\n        const stockCount = receivedQty;\r\n\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n\r\n            // Generate barcode data\r\n            const barcodeData = `${itemId}-${lastStockId}-${receivedStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image to folder\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Save barcode data in the database\r\n            const query = await db.query(insertDetailQuery, [itemId, lastStockId, receivedStockId, pngBuffer]);\r\n        }\r\n\r\n        // Determine new stock status\r\n        let newStatus = \"Incomplete\";\r\n        let newQty = currentQty - receivedQty;\r\n\r\n        if (receivedQty >= currentQty) {\r\n            newStatus = \"Complete\";\r\n            newQty = 0;\r\n        }\r\n\r\n        // Update production table\r\n        const sqlUpdate = `UPDATE production SET qty = ?, status = ? WHERE p_ID = ?`;\r\n        await db.query(sqlUpdate, [newQty, newStatus, p_ID]);\r\n\r\n        // Update stock quantity in Item table\r\n        const sqlUpdateItem = `UPDATE Item SET stockQty = stockQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem, [receivedQty, itemId]);\r\n\r\n        const sqlUpdateItem1 = `UPDATE Item SET availableQty = availableQty + ? WHERE I_Id = ?`;\r\n        await db.query(sqlUpdateItem1, [receivedQty, itemId]);\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Stock received updated successfully\",\r\n            updatedStatus: newStatus,\r\n            remainingQty: newQty,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating stock received:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\", details: error.message });\r\n    }\r\n});\r\n\r\n// Update order in invoice part\r\nrouter.put(\"/update-invoice\", async (req, res) => {\r\n    try {\r\n        console.log(req.body);\r\n\r\n        const {\r\n            orID,\r\n            isPickup,\r\n            netTotal,\r\n            totalAdvance,\r\n            previousAdvance,\r\n            balance,\r\n            addedAdvance,\r\n            updatedDeliveryCharge,\r\n            updatedDiscount\r\n        } = req.body;\r\n\r\n        if (!orID) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"Order ID is required\",\r\n            });\r\n        }\r\n\r\n        // \uD83D\uDD0D Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM Orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orID]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"Order not found\",\r\n            });\r\n        }\r\n\r\n        // \uD83D\uDD04 Determine Payment Status\r\n        let payStatus = \"Pending\"; // Default status\r\n\r\n        if (totalAdvance > 0) {\r\n            payStatus = \"Advanced\"; // Some advance payment has been made\r\n        }\r\n\r\n        if (balance === 0) {\r\n            payStatus = \"Settled\"; // Fully paid order\r\n        }\r\n\r\n        // \uD83D\uDD04 Update Orders table\r\n        const orderUpdateQuery = `\r\n            UPDATE Orders\r\n            SET total = ?, discount = ?, delPrice = ?, advance = ?, balance = ?, payStatus = ?\r\n            WHERE OrID = ?`;\r\n        const orderUpdateParams = [netTotal, updatedDiscount, updatedDeliveryCharge, totalAdvance, balance, payStatus, orID];\r\n        await db.query(orderUpdateQuery, orderUpdateParams);\r\n\r\n        // \uD83D\uDED1 If it's a pickup order, remove it from the delivery table\r\n        if (isPickup) {\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orID]);\r\n        }\r\n\r\n        // \uD83D\uDD52 Get the current date and time\r\n        const currentDateTime = new Date().toISOString().slice(0, 19).replace(\"T\", \" \");\r\n\r\n        // \uD83D\uDCB0 Insert a new entry into the Payment table\r\n        if (addedAdvance > 0) {\r\n            const insertPaymentQuery = `\r\n                INSERT INTO Payment (orID, amount, dateTime)\r\n                VALUES (?, ?, ?)`;\r\n            const paymentParams = [orID, addedAdvance, currentDateTime];\r\n            await db.query(insertPaymentQuery, paymentParams);\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order and payment updated successfully\",\r\n            payStatus,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"❌ Error updating invoice:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating invoice data\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch Accept orders in booked-unbooked\r\nrouter.get(\"/orders-accept\", async (req, res) => {\r\n    try {\r\n        // Step 1: Fetch all the orders and their associated items' statuses from the accept_orders table.\r\n        const query = `\r\n            SELECT\r\n                o.OrID, o.orDate, o.c_ID, o.ordertype, o.orStatus, o.delStatus, o.delPrice,\r\n                o.discount, o.advance, o.balance, o.payStatus, o.total, o.stID, o.expectedDate AS expectedDeliveryDate,\r\n                ao.itemReceived,\r\n                ao.status AS acceptanceStatus\r\n            FROM Orders o\r\n                     LEFT JOIN accept_orders ao ON o.OrID = ao.orID\r\n            WHERE o.orStatus = 'Accepted'\r\n        `;\r\n\r\n        const [orders] = await db.query(query);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ message: \"No Accepted orders found\" });\r\n        }\r\n\r\n        const groupedOrders = {};\r\n        const bookedOrders = [];\r\n        const unbookedOrders = [];\r\n\r\n        // Step 3: Process each order and its items.\r\n        orders.forEach(order => {\r\n            if (!groupedOrders[order.OrID]) {\r\n                groupedOrders[order.OrID] = {\r\n                    OrID: order.OrID,\r\n                    orDate: order.orDate,\r\n                    customer: order.c_ID,\r\n                    ordertype: order.ordertype,\r\n                    orStatus: order.orStatus,\r\n                    dvStatus: order.delStatus,\r\n                    dvPrice: order.delPrice,\r\n                    disPrice: order.discount,\r\n                    totPrice: order.total,\r\n                    advance: order.advance,\r\n                    balance: order.balance,\r\n                    payStatus: order.payStatus,\r\n                    stID: order.stID,\r\n                    expectedDeliveryDate: order.expectedDeliveryDate,\r\n                    acceptanceStatuses: [],\r\n                    isUnbooked: false\r\n                };\r\n            }\r\n\r\n            groupedOrders[order.OrID].acceptanceStatuses.push(order.acceptanceStatus);\r\n\r\n            if (order.acceptanceStatus !== \"Complete\") {\r\n                groupedOrders[order.OrID].isUnbooked = true;\r\n            }\r\n        });\r\n\r\n        // Step 4: Categorize orders.\r\n        Object.values(groupedOrders).forEach(order => {\r\n            if (order.isUnbooked) {\r\n                order.acceptanceStatus = \"Incomplete\";\r\n                unbookedOrders.push(order);\r\n            } else {\r\n                order.acceptanceStatus = \"Complete\";\r\n                bookedOrders.push(order);\r\n            }\r\n        });\r\n\r\n        return res.status(200).json({\r\n            message: \"Accepted orders found.\",\r\n            bookedOrders: bookedOrders,\r\n            unbookedOrders: unbookedOrders\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching accepted orders:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching accepted orders\", error: error.message });\r\n    }\r\n});\r\n\r\n// Update order\r\nrouter.put(\"/update-order-details\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderDate, orderStatus,payStatus,phoneNumber,optionalNumber,netTotal,customerId,\r\n            deliveryStatus, deliveryCharge, discount, totalPrice,advance , balance , expectedDeliveryDate, specialNote } = req.body;\r\n        // Check if the order exists\r\n        const orderCheckQuery = `SELECT * FROM orders WHERE OrID = ?`;\r\n        const [orderResult] = await db.query(orderCheckQuery, [orderId]);\r\n\r\n        if (orderResult.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Order not found\" });\r\n        }\r\n\r\n        if (advance === 0 && payStatus === 'Advanced'){\r\n\r\n            return res.status(404).json({ success: false, message: \"payement status cannot change to advance when advance is 0\" });\r\n        }\r\n\r\n        //Update order details\r\n        const orderUpdateQuery = `\r\n            UPDATE orders SET c_ID =?, orStatus = ?, payStatus = ?,delStatus = ?, delPrice = ?, discount = ?,\r\n                              total = ?, advance = ?, balance = ?, specialNote = ?, netTotal=?\r\n            WHERE OrID = ?`;\r\n        await db.query(orderUpdateQuery, [\r\n            customerId, orderStatus, payStatus, deliveryStatus, deliveryCharge, discount, totalPrice,\r\n            advance, balance, specialNote,netTotal, orderId\r\n        ]);\r\n        // return res.status(200).json({ success: true, message: \"Order details updated successfully\" });\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Order updated successfully\",\r\n            data: {\r\n                orderId: orderId,\r\n                orderDate: orderDate,\r\n                expectedDeliveryDate: expectedDeliveryDate,\r\n            },\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order data:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating data in database\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\nrouter.put(\"/update-order-items\", async (req, res) => {\r\n    try {\r\n        const { orderId, orderStatus, items } = req.body;\r\n\r\n        if (!items || items.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"No items provided.\" });\r\n        }\r\n// Fetch existing order details from the database\r\n        const checkOrderItemsQuery = `SELECT I_Id FROM Order_Detail WHERE orID = ?`;\r\n        const [existingRecords] = await db.query(checkOrderItemsQuery, [orderId]);\r\n\r\n        const existingItemIds = existingRecords.map(item => item.I_Id);\r\n        const newItemIds = items.map(item => item.itemId);\r\n\r\n// Identify items to remove (exist in DB but not in the request)\r\n        const itemsToRemove = existingItemIds.filter(id => !newItemIds.includes(id));\r\n\r\n        console.log(\"Existing records:\", existingItemIds);\r\n        console.log(\"New records:\", newItemIds);\r\n        console.log(\"Items to remove:\", itemsToRemove);\r\n\r\n// Remove missing items from Order_Detail\r\n        for (const itemId of itemsToRemove) {\r\n            const deleteOrderDetailQuery = `DELETE FROM Order_Detail WHERE orID = ? AND I_Id = ?`;\r\n            await db.query(deleteOrderDetailQuery, [orderId, itemId]);\r\n            const deleteAccceptDetailQuery = `DELETE FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            await db.query(deleteAccceptDetailQuery, [orderId, itemId]);\r\n        }\r\n\r\n// Update or Insert new items\r\n        for (const item of items){\r\n            //Check if the record exists in order detail table\r\n            const checkOrderDetailQuery = `SELECT * FROM Order_Detail WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkOrderDetailQuery, [orderId, item.itemId]);\r\n\r\n            if (existingRecord.length > 0) {\r\n                const updateAcceptOrderQuery = `UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [item.quantity , item.price , orderId, item.itemId]);\r\n            } else {\r\n                const insertAcceptOrderQuery = `INSERT INTO Order_Detail (orID, I_Id, qty, tprice) VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [orderId, item.itemId, item.quantity , item.price]);\r\n            }\r\n        }\r\n\r\n        // Ensure order status is 'Accepted' if any item is booked\r\n        const isAnyItemBooked = items.some(item => item.booked);\r\n        if (isAnyItemBooked && orderStatus !== \"Accepted\") {\r\n            return res.status(400).json({ success: false, message: \"Order status must be 'Accepted' if any item is booked.\" });\r\n        }\r\n\r\n        for (const item of items) {\r\n            const itemReceived = item.booked ? \"Yes\" : \"No\";\r\n            const itemStatus = item.booked ? \"Complete\" : \"Incomplete\";\r\n\r\n            // Check if the record exists in accept_orders\r\n            const checkAcceptOrderQuery = `SELECT * FROM accept_orders WHERE orID = ? AND I_Id = ?`;\r\n            const [existingRecord] = await db.query(checkAcceptOrderQuery, [orderId, item.itemId]);\r\n\r\n            if (existingRecord.length > 0) {\r\n                const updateAcceptOrderQuery = `UPDATE accept_orders SET itemReceived = ?, status = ? WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(updateAcceptOrderQuery, [itemReceived, itemStatus, orderId, item.itemId]);\r\n            } else {\r\n                const insertAcceptOrderQuery = `INSERT INTO accept_orders (orID, I_Id, itemReceived, status) VALUES (?, ?, ?, ?)`;\r\n                await db.query(insertAcceptOrderQuery, [orderId, item.itemId, itemReceived, itemStatus]);\r\n            }\r\n\r\n            // Handle booking & inventory\r\n            if (item.booked) {\r\n                const checkBookedItemQuery = `SELECT * FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                const [existingBookedItem] = await db.query(checkBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                if (existingBookedItem.length === 0) {\r\n                    const bookItemQuery = `INSERT INTO booked_item (orID, I_Id, qty) VALUES (?, ?, ?)`;\r\n                    await db.query(bookItemQuery, [orderId, item.itemId, item.quantity]);\r\n\r\n                    // Update inventory\r\n                    const updateItemQtyQuery = `UPDATE Item SET bookedQty = bookedQty + ?, availableQty = availableQty - ? WHERE I_Id = ?`;\r\n                    await db.query(updateItemQtyQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            } else {\r\n                // Remove from booked items & restore inventory\r\n                const deleteBookedItemQuery = `DELETE FROM booked_item WHERE orID = ? AND I_Id = ?`;\r\n                await db.query(deleteBookedItemQuery, [orderId, item.itemId]);\r\n\r\n                const checkIfBookedQuery = `SELECT * FROM Item WHERE I_Id = ? AND bookedQty >= ?`;\r\n                const [bookedCheck] = await db.query(checkIfBookedQuery, [item.itemId, item.quantity]);\r\n\r\n                if (bookedCheck.length > 0) {\r\n                    const restoreStockQuery = `UPDATE Item SET bookedQty = bookedQty - ?, availableQty = availableQty + ? WHERE I_Id = ?`;\r\n                    await db.query(restoreStockQuery, [item.quantity, item.quantity, item.itemId]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Order items updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order items:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\nrouter.put(\"/update-delivery\", async (req, res) => {\r\n    try {\r\n        const { orderId, deliveryStatus, phoneNumber, deliveryInfo } = req.body;\r\n        console.log(orderId , deliveryInfo , deliveryStatus , phoneNumber);\r\n\r\n        if (!orderId || !deliveryStatus) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        if (deliveryStatus === \"Delivery\" && deliveryInfo) {\r\n            // Check if a delivery record already exists\r\n            const checkDeliveryQuery = `SELECT * FROM delivery WHERE orID = ?`;\r\n            const [existingDelivery] = await db.query(checkDeliveryQuery, [orderId]);\r\n\r\n            if (existingDelivery.length > 0) {\r\n                // Update existing delivery record\r\n                const deliveryUpdateQuery = `UPDATE delivery SET address = ?, district = ?, contact = ?, schedule_Date = ? WHERE orID = ?`;\r\n                await db.query(deliveryUpdateQuery, [deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate, orderId]);\r\n            } else {\r\n                // Insert new delivery record\r\n                const insertDeliveryQuery = `INSERT INTO delivery (orID, address, district, contact, schedule_Date) VALUES (?, ?, ?, ?, ?)`;\r\n                await db.query(insertDeliveryQuery, [orderId, deliveryInfo.address, deliveryInfo.district, phoneNumber, deliveryInfo.scheduleDate]);\r\n            }\r\n        }\r\n\r\n        if (deliveryStatus === \"Pick Up\") {\r\n            // Remove any existing delivery record\r\n            const deleteDeliveryQuery = `DELETE FROM delivery WHERE orID = ?`;\r\n            await db.query(deleteDeliveryQuery, [orderId]);\r\n\r\n            // Update the delivery price to 0 in orders\r\n            const updateDeliveryQuery = `UPDATE orders SET dvPrice = 0 WHERE orID = ?`;\r\n            await db.query(updateDeliveryQuery, [orderId]);\r\n        }\r\n\r\n        return res.status(200).json({ success: true, message: \"Delivery information updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating delivery information:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Database update failed\", details: error.message });\r\n    }\r\n});\r\n\r\n//Get All sale team members\r\nrouter.get(\"/salesteam\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all sales team members with their details\r\n        const [salesTeam] = await db.query(`\r\n            SELECT\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                e.E_Id,\r\n                e.name AS employeeName,\r\n                e.address,\r\n                e.nic,\r\n                e.dob,\r\n                e.contact,\r\n                e.job,\r\n                e.basic\r\n            FROM sales_team st\r\n            JOIN Employee e ON st.E_Id = e.E_Id;\r\n        `);\r\n\r\n        // If no sales team members found, return a 404 status\r\n        if (salesTeam.length === 0) {\r\n            return res.status(404).json({ message: \"No sales team members found\" });\r\n        }\r\n\r\n        // Query to fetch coupons for each sales team member\r\n        const [coupons] = await db.query(`\r\n            SELECT\r\n                sc.cpID,\r\n                sc.stID,\r\n                sc.discount\r\n            FROM sales_coupon sc;\r\n        `);\r\n\r\n        // Group coupons by stID\r\n        const couponMap = {};\r\n        coupons.forEach(coupon => {\r\n            if (!couponMap[coupon.stID]) {\r\n                couponMap[coupon.stID] = [];\r\n            }\r\n            couponMap[coupon.stID].push({\r\n                cpID: coupon.cpID,\r\n                discount: coupon.discount\r\n            });\r\n        });\r\n\r\n        // Format the response data\r\n        const formattedSalesTeam = salesTeam.map(member => ({\r\n            stID: member.stID,\r\n            E_Id: member.E_Id,\r\n            employeeName: member.employeeName,\r\n            address: member.address,\r\n            nic: member.nic,\r\n            dob: member.dob,\r\n            contact: member.contact,\r\n            job: member.job,\r\n            basic: member.basic,\r\n            orderTarget: member.orderTarget,\r\n            issuedTarget: member.issuedTarget,\r\n            totalOrder: member.totalOrder,\r\n            totalIssued: member.totalIssued,\r\n            coupons: couponMap[member.stID] || [] // Attach coupons or empty array if none exist\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Sales team members and their coupons retrieved successfully.\",\r\n            data: formattedSalesTeam\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching sales team members and coupons:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching sales team members and coupons\" });\r\n    }\r\n});\r\n\r\n//Get All driver members\r\nrouter.get(\"/drivers\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all drivers and their related employee details\r\n        const [drivers] = await db.query(`\r\n            SELECT\r\n                d.devID,\r\n                d.balance,\r\n                e.E_Id,\r\n                e.name AS employeeName,\r\n                e.address,\r\n                e.nic,\r\n                e.dob,\r\n                e.contact,\r\n                e.job,\r\n                e.basic\r\n            FROM driver d\r\n                     JOIN Employee e ON d.E_ID = e.E_Id;\r\n        `);\r\n\r\n        // If no drivers are found, return a 404 status\r\n        if (drivers.length === 0) {\r\n            return res.status(404).json({ message: \"No drivers found\" });\r\n        }\r\n\r\n        // Format the response data\r\n        const formattedDrivers = drivers.map(driver => ({\r\n            devID: driver.devID,\r\n            E_Id: driver.E_Id,\r\n            employeeName: driver.employeeName,\r\n            address: driver.address,\r\n            nic: driver.nic,\r\n            dob: driver.dob,\r\n            contact: driver.contact,\r\n            job: driver.job,\r\n            basic: driver.basic,\r\n            balance: driver.balance\r\n        }));\r\n\r\n        // Send the formatted data as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Drivers found.\",\r\n            data: formattedDrivers\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching drivers:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching drivers\" });\r\n    }\r\n});\r\n\r\n// Get orders for a specific sales team member (stID)\r\nrouter.get(\"/orders/by-sales-team\", async (req, res) => {\r\n    try {\r\n        const { stID } = req.query;\r\n        console.log(stID);\r\n\r\n        // Fetch sales team details and orders (without duplicate coupons)\r\n        const [results] = await db.query(`\r\n            SELECT\r\n                e.E_Id AS employeeId,\r\n                e.name AS employeeName,\r\n                e.contact AS employeeContact,\r\n                e.nic AS employeeNic,\r\n                e.dob AS employeeDob,\r\n                e.address AS employeeAddress,\r\n                e.job AS employeeJob,\r\n                e.basic AS employeeBasic,\r\n                st.stID,\r\n                st.orderTarget,\r\n                st.issuedTarget,\r\n                st.totalOrder,\r\n                st.totalIssued,\r\n                COUNT(o.OrID) AS totalCount,\r\n                SUM(CASE WHEN o.orStatus = 'issued' THEN 1 ELSE 0 END) AS issuedCount,\r\n                COALESCE(SUM(o.total), 0) AS totalOrderValue,\r\n                COALESCE(SUM(CASE WHEN o.orStatus = 'issued' THEN o.total ELSE 0 END), 0) AS issuedOrderValue\r\n            FROM sales_team st\r\n            JOIN Employee e ON e.E_Id = st.E_Id\r\n            LEFT JOIN Orders o ON o.stID = st.stID\r\n            WHERE st.stID = ?\r\n            GROUP BY st.stID, e.E_Id, e.name, e.contact, e.nic, e.dob, e.address, e.job, e.basic,\r\n                     st.orderTarget, st.issuedTarget, st.totalOrder, st.totalIssued;\r\n        `, [stID]);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ message: \"No data found for this sales team member.\" });\r\n        }\r\n\r\n        // Extract member details\r\n        const memberDetails = results[0];\r\n\r\n        // Fetch orders separately\r\n        const [orders] = await db.query(`\r\n            SELECT\r\n                o.OrID AS orderId,\r\n                o.orDate AS orderDate,\r\n                o.total AS totalPrice,\r\n                o.orStatus AS orderStatus\r\n            FROM Orders o\r\n            WHERE o.stID = ?;\r\n        `, [stID]);\r\n\r\n        // Fetch coupon separately (ensuring only one per sales team member)\r\n        const [coupons] = await db.query(`\r\n            SELECT\r\n                sc.cpID AS couponId,\r\n                sc.discount AS couponDiscount\r\n            FROM sales_coupon sc\r\n            WHERE sc.stID = ?;\r\n        `, [stID]);\r\n\r\n        return res.status(200).json({\r\n            message: \"Sales team details, orders, and coupons fetched successfully.\",\r\n            data: {\r\n                memberDetails,\r\n                orders: orders.length > 0 ? orders : [],\r\n                coupons: coupons.length > 0 ? [coupons[0]] : [] // ✅ Ensure only one coupon is included\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching orders, member details, and coupons:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching orders, member details, and coupons.\" });\r\n    }\r\n});\r\n\r\n// Get all categories\r\nrouter.get(\"/categories\", async (req, res) => {\r\n    try {\r\n        // Query the database to fetch all categories\r\n        const [categories] = await db.query(\"SELECT * FROM Category\");\r\n\r\n        // If no categories found, return a 404 status\r\n        if (categories.length === 0) {\r\n            return res.status(404).json({ message: \"No categories found\" });\r\n        }\r\n\r\n        // Map through categories to format the response\r\n        const formattedCategories = categories.map(category => ({\r\n            id: category.Ca_Id,  // Assuming you have a Ca_Id column for the category ID\r\n            name: category.name   // Assuming you have a name column for the category name\r\n        }));\r\n\r\n        // Send the formatted categories as a JSON response\r\n        return res.status(200).json(formattedCategories);\r\n    } catch (error) {\r\n        console.error(\"Error fetching categories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching categories\" });\r\n    }\r\n});\r\n\r\n//API to Get All Sub Categories (sub_one and sub_two) by Category ID (Ca_Id):\r\nrouter.get(\"/subcategories\", async (req, res) => {\r\n    try {\r\n        const { Ca_Id } = req.query;\r\n\r\n        if (!Ca_Id) {\r\n            return res.status(400).json({ message: \"Category ID is required.\" });\r\n        }\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// find subcat one and two data by category name\r\nrouter.get(\"/SubCatNames\", async (req, res) => {\r\n    try {\r\n        const { categoryName } = req.query;\r\n\r\n        if (!categoryName) {\r\n            return res.status(400).json({ message: \"Category name is required.\" });\r\n        }\r\n\r\n        // Fetch the Ca_Id based on the category name\r\n        const [categoryResult] = await db.query(`\r\n            SELECT Ca_Id FROM Category WHERE name = ?;\r\n        `, [categoryName]);\r\n\r\n        if (categoryResult.length === 0) {\r\n            return res.status(404).json({ message: \"Category not found.\" });\r\n        }\r\n\r\n        const Ca_Id = categoryResult[0].Ca_Id;\r\n\r\n        // Fetch subCat_one and related subCat_two details for the given Ca_Id\r\n        const [subCategories] = await db.query(`\r\n            SELECT\r\n                s1.sb_c_id AS subCatOneId,\r\n                s1.subcategory AS subCatOneName,\r\n                s1.img AS subCatOneImg,\r\n                s2.sb_cc_id AS subCatTwoId,\r\n                s2.subcategory AS subCatTwoName,\r\n                s2.img AS subCatTwoImg\r\n            FROM subCat_one s1\r\n                     LEFT JOIN subCat_two s2 ON s1.sb_c_id = s2.sb_c_id\r\n            WHERE s1.Ca_Id = ?;\r\n        `, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({ message: \"No subcategories found for this category.\" });\r\n        }\r\n\r\n        // Group subCat_two under corresponding subCat_one and set \"None\" if empty\r\n        const groupedData = subCategories.reduce((acc, curr) => {\r\n            const existingSubCatOne = acc.find(item => item.subCatOneId === curr.subCatOneId);\r\n\r\n            const subCatTwoItem = curr.subCatTwoId\r\n                ? {\r\n                    subCatTwoId: curr.subCatTwoId,\r\n                    subCatTwoName: curr.subCatTwoName,\r\n                    subCatTwoImg: curr.subCatTwoImg\r\n                }\r\n                : { subCatTwoId: \"None\", subCatTwoName: \"None\", subCatTwoImg: null };\r\n\r\n            if (existingSubCatOne) {\r\n                if (!existingSubCatOne.subCatTwo.some(item => item.subCatTwoId === subCatTwoItem.subCatTwoId)) {\r\n                    existingSubCatOne.subCatTwo.push(subCatTwoItem);\r\n                }\r\n            } else {\r\n                acc.push({\r\n                    subCatOneId: curr.subCatOneId,\r\n                    subCatOneName: curr.subCatOneName,\r\n                    subCatOneImg: curr.subCatOneImg,\r\n                    subCatTwo: [subCatTwoItem]\r\n                });\r\n            }\r\n\r\n            return acc;\r\n        }, []);\r\n\r\n        return res.status(200).json({\r\n            message: \"Subcategories fetched successfully.\",\r\n            data: groupedData\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching subcategories:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching subcategories.\" });\r\n    }\r\n});\r\n\r\n// API endpoint to save item-supplier association\r\nrouter.post('/add-item-supplier', async (req, res) => {\r\n    const { I_Id, s_ID ,cost } = req.body;\r\n\r\n    // Check if I_Id and s_ID are provided\r\n    if (!I_Id || !s_ID ) {\r\n        return res.status(400).json({ success: false, message: 'Item ID and Supplier ID are required' });\r\n    }\r\n\r\n    try {\r\n        // Step 1: Check if the Item ID exists in the Item table\r\n        const [itemExists] = await db.query('SELECT * FROM Item WHERE I_Id = ?', [I_Id]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Item not found' });\r\n        }\r\n\r\n        // Step 2: Check if the Supplier ID exists in the Supplier table\r\n        const [supplierExists] = await db.query('SELECT * FROM Supplier WHERE s_ID = ?', [s_ID]);\r\n        if (supplierExists.length === 0) {\r\n            return res.status(404).json({ success: false, message: 'Supplier not found' });\r\n        }\r\n\r\n        // Step 3: Insert the item-supplier relationship into the item_supplier table\r\n        const insertQuery = 'INSERT INTO item_supplier (I_Id, s_ID,unit_cost) VALUES (?, ?,?)';\r\n        const [result] = await db.query(insertQuery, [I_Id, s_ID,cost]);\r\n\r\n        // Step 4: Return success response\r\n        return res.status(200).json({ success: true, message: 'Item-Supplier relationship added successfully', data: result });\r\n    } catch (error) {\r\n        console.error('Error adding item-supplier:', error.message);\r\n        return res.status(500).json({ success: false, message: 'Server error', error: error.message });\r\n    }\r\n});\r\n\r\n// Route for adding stock with barcode generation\r\nrouter.post(\"/add-stock-received\", upload.single(\"image\"), async (req, res) => {\r\n    try {\r\n        const { supplierId, itemId, date, cost, stockCount, comment } = req.body;\r\n        const imageFile = req.file;\r\n\r\n        // Validate required fields\r\n        if (!supplierId || !itemId || !date || !stockCount) {\r\n            return res.status(400).json({ success: false, message: \"All fields are required!\" });\r\n        }\r\n\r\n        // Validate item existence\r\n        const [itemExists] = await db.query(\"SELECT I_Id FROM Item WHERE I_Id = ?\", [itemId]);\r\n        if (itemExists.length === 0) {\r\n            return res.status(400).json({ success: false, message: \"Invalid Item ID\" });\r\n        }\r\n\r\n        // Handle image upload\r\n        let imagePath = null;\r\n        if (imageFile) {\r\n            const imageName = `item_${itemId}_${Date.now()}.${imageFile.mimetype.split(\"/\")[1]}`;\r\n            const savePath = path.join(\"./uploads/images\", imageName);\r\n            fs.writeFileSync(savePath, imageFile.buffer);\r\n            imagePath = `/uploads/images/${imageName}`;\r\n        }\r\n\r\n        // Insert into main_stock_received\r\n        const insertQuery = `\r\n            INSERT INTO main_stock_received (s_ID, I_Id, rDate, rec_count, unitPrice, detail)\r\n            VALUES (?, ?, ?, ?, ?, ?)`;\r\n        const [result] = await db.query(insertQuery, [supplierId, itemId, date, stockCount, cost, comment || \"\"]);\r\n        const receivedStockId = result.insertId;\r\n\r\n        // Update Item table stock\r\n        await db.query(\r\n            `UPDATE Item SET stockQty = stockQty + ?, availableQty = availableQty + ? WHERE I_Id = ?`,\r\n            [stockCount, stockCount, itemId]\r\n        );\r\n\r\n        // Get last stock_Id\r\n        const [lastStockResult] = await db.query(\r\n            `SELECT MAX(stock_Id) AS lastStockId FROM m_s_r_detail WHERE I_Id = ?`,\r\n            [itemId]\r\n        );\r\n        let lastStockId = lastStockResult[0]?.lastStockId || 0;\r\n\r\n        console.log(\"Last stock ID before insert:\", lastStockId);\r\n\r\n        const insertDetailQuery = `\r\n            INSERT INTO m_s_r_detail (I_Id, stock_Id, sr_ID, barcode, status, orID, datetime)\r\n            VALUES (?, ?, ?, ?, 'Available', ?, NOW())`;\r\n\r\n        // Ensure barcodes folder exists\r\n        const barcodeFolderPath = path.join(\"./uploads/barcodes\");\r\n        if (!fs.existsSync(barcodeFolderPath)) {\r\n            fs.mkdirSync(barcodeFolderPath, { recursive: true });\r\n        }\r\n\r\n        for (let i = 1; i <= stockCount; i++) {\r\n            lastStockId++;\r\n\r\n            // Create barcode data\r\n            const barcodeData = `${itemId}-${lastStockId}-${receivedStockId}`;\r\n            const barcodeImageName = `barcode_${barcodeData}.png`;\r\n            const barcodeImagePath = path.join(barcodeFolderPath, barcodeImageName);\r\n\r\n            // Generate barcode image\r\n            const pngBuffer = await bwipjs.toBuffer({\r\n                bcid: \"code128\",\r\n                text: barcodeData,\r\n                scale: 3,\r\n                height: 10,\r\n                includetext: true,\r\n                textxalign: \"center\",\r\n            });\r\n\r\n            // Save barcode image to folder\r\n            fs.writeFileSync(barcodeImagePath, pngBuffer);\r\n\r\n            // Save barcode details in the database\r\n            await db.query(insertDetailQuery, [itemId, lastStockId, receivedStockId, barcodeData, \"\"]);\r\n            console.log(`Inserted barcode for stock ID: ${lastStockId}`);\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Stock received successfully, image uploaded, and barcodes saved!\",\r\n            stockReceivedId: receivedStockId,\r\n            imagePath,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error adding stock received:\", error);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Find cost by sid and iid\r\nrouter.get(\"/find-cost\", async (req, res) => {\r\n    try {\r\n        const { s_ID , I_Id } = req.query;\r\n\r\n        if (!s_ID || !I_Id ) {\r\n            return res.status(400).json({ message: \"Item ID, Supplier Id are required.\" });\r\n        }\r\n\r\n        // Query the database to fetch the type for the given Ca_Id, sub_one, and sub_two\r\n        const [cost] = await db.query(`\r\n            SELECT unit_cost\r\n            FROM item_supplier\r\n            WHERE s_ID = ? AND I_Id = ? ;\r\n        `, [s_ID,I_Id]);\r\n\r\n        // If no type found for this combination, return a 404 status\r\n        if (cost.length === 0) {\r\n            return res.status(404).json({ message: \"No cost found.\" });\r\n        }\r\n\r\n        // Send the type as a JSON response\r\n        return res.status(200).json({\r\n            message: \"Cost found.\",\r\n            cost: cost[0],  // Return only the first matching cost\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching cost:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching cost\" });\r\n    }\r\n});\r\n\r\n//find issuded orders by district & date\r\nrouter.get(\"/find-completed-orders\", async (req, res) => {\r\n    try {\r\n        const { district, date } = req.query;\r\n        console.log(district, date);\r\n\r\n        if (!district) {\r\n            return res.status(400).json({ success: false, message: \"District is required.\" });\r\n        }\r\n\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Parse the date in DD/MM/YYYY format and convert it to YYYY-MM-DD format\r\n        const parsedDate = parseDate(date);\r\n        console.log(parsedDate);\r\n\r\n        // 1\uFE0F⃣ Fetch Completed Orders with Sales Team & Customer Details\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount, \r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance, \r\n                o.payStatus, d.address, d.district, d.schedule_Date, d.type,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n            JOIN delivery d ON o.orID = d.orID\r\n            LEFT JOIN sales_team s ON o.stID = s.stID\r\n            LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n            LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE d.district = ? AND o.orStatus = 'Completed' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [district, parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No completed orders found for this district and date.\" });\r\n        }\r\n\r\n        // 2\uFE0F⃣ Fetch Ordered Items for Each Order\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            const itemsQuery = `\r\n                SELECT\r\n                    od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                    i.bookedQty, i.availableQty\r\n                FROM Order_Detail od\r\n                JOIN Item i ON od.I_Id = i.I_Id\r\n                WHERE od.orID = ?`;\r\n\r\n            const [items] = await db.query(itemsQuery, [order.orId]);\r\n\r\n            // 3\uFE0F⃣ Fetch Booked Items for Each Order\r\n            const bookedItemsQuery = `\r\n                SELECT bi.I_Id, i.I_name, bi.qty\r\n                FROM booked_item bi\r\n                JOIN Item i ON bi.I_Id = i.I_Id\r\n                WHERE bi.orID = ?`;\r\n\r\n            const [bookedItems] = await db.query(bookedItemsQuery, [order.orId]);\r\n\r\n            // 4\uFE0F⃣ Fetch Accepted Items\r\n            const acceptedOrdersQuery = `\r\n                SELECT ao.I_Id, i.I_name, ao.itemReceived, ao.status\r\n                FROM accept_orders ao\r\n                JOIN Item i ON ao.I_Id = i.I_Id\r\n                WHERE ao.orID = ?`;\r\n\r\n            const [acceptedOrders] = await db.query(acceptedOrdersQuery, [order.orId]);\r\n\r\n            // 5\uFE0F⃣ Build the Response Object\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryPrice : order.delPrice,\r\n                discount : order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type : order.type,\r\n                },\r\n                items: items.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    price: item.tprice,\r\n                    unitPrice: item.unitPrice,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                })),\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName, // Sales team member's name\r\n                },\r\n                bookedItems: bookedItems.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty\r\n                })),\r\n                acceptedOrders: acceptedOrders.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    itemReceived: item.itemReceived,\r\n                    status: item.status\r\n                }))\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Completed orders fetched successfully.\",\r\n            orders: orderDetails\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching completed orders.\",\r\n            details: error.message\r\n        });\r\n    }\r\n});\r\n\r\n//find issuded orders by  date\r\nrouter.get(\"/find-completed-orders-by-date\", async (req, res) => {\r\n    try {\r\n        const { date } = req.query;\r\n        console.log(date);\r\n        if (!date) {\r\n            return res.status(400).json({ success: false, message: \"Date is required.\" });\r\n        }\r\n\r\n        // Ensure the date is in `YYYY-MM-DD` format for the database query\r\n        const parsedDate = parseDate(date);\r\n        if (!parsedDate) {\r\n            return res.status(400).json({ success: false, message: \"Invalid date format. Use DD/MM/YYYY or YYYY-MM-DD.\" });\r\n        }\r\n\r\n        console.log(\"Fetching completed orders for date:\", parsedDate);\r\n\r\n        // Fetch completed orders with customer details, sales team, and employee name\r\n        const orderQuery = `\r\n            SELECT\r\n                o.orId, o.orDate, o.c_ID, o.orStatus, o.delStatus, o.delPrice, o.discount,\r\n                o.total, o.ordertype, o.stID, o.expectedDate, o.specialNote, o.advance, o.balance,\r\n                o.payStatus, d.address, d.district, d.type, d.status AS deliveryStatus, d.schedule_Date,\r\n                s.stID, e.name AS salesEmployeeName,\r\n                c.FtName, c.SrName, c.contact1, c.contact2\r\n            FROM Orders o\r\n                     JOIN delivery d ON o.orID = d.orID\r\n                     LEFT JOIN sales_team s ON o.stID = s.stID\r\n                     LEFT JOIN Employee e ON s.E_Id = e.E_Id\r\n                     LEFT JOIN Customer c ON o.c_ID = c.c_ID\r\n            WHERE o.orStatus = 'Completed' AND o.expectedDate = ?;\r\n        `;\r\n\r\n        const [orders] = await db.query(orderQuery, [parsedDate]);\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No completed orders found for this date.\" });\r\n        }\r\n\r\n        // Process orders\r\n        const orderDetails = await Promise.all(orders.map(async (order) => {\r\n            const itemsQuery = `\r\n                SELECT od.I_Id, i.I_name, i.color, od.qty, od.tprice, i.price AS unitPrice,\r\n                       i.bookedQty, i.availableQty\r\n                FROM Order_Detail od\r\n                JOIN Item i ON od.I_Id = i.I_Id\r\n                WHERE od.orID = ?`;\r\n\r\n            const [items] = await db.query(itemsQuery, [order.orId]);\r\n\r\n            return {\r\n                orderId: order.orId,\r\n                orderDate: formatDate(order.orDate),\r\n                expectedDeliveryDate: formatDate(order.expectedDate),\r\n                customerId: order.c_ID,\r\n                customerName: `${order.FtName} ${order.SrName}`,\r\n                phoneNumber: order.contact1,\r\n                optionalNumber: order.contact2,\r\n                orderStatus: order.orStatus,\r\n                deliveryStatus: order.delStatus,\r\n                totalPrice: order.total,\r\n                deliveryPrice: order.delPrice,\r\n                discount: order.discount,\r\n                advance: order.advance,\r\n                balance: order.balance,\r\n                payStatus: order.payStatus,\r\n                deliveryInfo: {\r\n                    address: order.address,\r\n                    district: order.district,\r\n                    scheduleDate: formatDate(order.schedule_Date),\r\n                    type: order.type,\r\n                },\r\n                items: items.map(item => ({\r\n                    itemId: item.I_Id,\r\n                    itemName: item.I_name,\r\n                    quantity: item.qty,\r\n                    color: item.color,\r\n                    price: item.tprice,\r\n                    unitPrice: item.unitPrice,\r\n                    bookedQuantity: item.bookedQty,\r\n                    availableQuantity: item.availableQty,\r\n                })),\r\n                salesTeam: {\r\n                    stID: order.stID,\r\n                    employeeName: order.salesEmployeeName, // Sales team member's name\r\n                },\r\n            };\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Completed orders fetched successfully.\",\r\n            orders: orderDetails,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching completed orders:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching completed orders.\",\r\n            details: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat one detail by ca_id\r\nrouter.get(\"/getSubcategories\", async (req, res) => {\r\n    const { Ca_Id } = req.query;\r\n    console.log(Ca_Id);\r\n    if (!Ca_Id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Category ID (Ca_Id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategories under the given category ID\r\n        const sqlSubcategories = `SELECT sb_c_id, subcategory FROM subCat_one WHERE Ca_Id = ?`;\r\n        const [subCategories] = await db.query(sqlSubcategories, [Ca_Id]);\r\n\r\n        if (subCategories.length === 0) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: \"No subcategories found for the given category ID\",\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategories.map(subCat => ({\r\n                sb_c_id: subCat.sb_c_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Get subcat two detail by ca_id\r\nrouter.get(\"/getSubcategoriesTwo\", async (req, res) => {\r\n    const { sb_c_id } = req.query;\r\n\r\n    if (!sb_c_id) {\r\n        return res.status(400).json({\r\n            success: false,\r\n            message: \"Subcategory One ID (sb_c_id) is required\",\r\n        });\r\n    }\r\n\r\n    try {\r\n        // Fetch subcategory two names under the given subcategory one ID\r\n        const sqlSubcategoriesTwo = `SELECT sb_cc_id, subcategory FROM subCat_two WHERE sb_c_id = ?\r\n        `;\r\n        const [subCategoriesTwo] = await db.query(sqlSubcategoriesTwo, [sb_c_id]);\r\n\r\n        if (subCategoriesTwo.length === 0) {\r\n            return res.status(200).json({\r\n                success: true,\r\n                message: \"No subcategories found\",\r\n                data: [{ sb_cc_id: \"None\", subcategory: \"None\" }],\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Subcategories retrieved successfully\",\r\n            data: subCategoriesTwo.map(subCat => ({\r\n                sb_cc_id: subCat.sb_cc_id,\r\n                subcategory: subCat.subcategory\r\n            })),\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error fetching subcategories:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching data from database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Category\r\nrouter.post(\"/category\", async (req, res) => {\r\n    try {\r\n        // Fetch the last inserted category ID\r\n        const [lastCategory] = await db.query(\"SELECT Ca_Id FROM Category ORDER BY Ca_Id DESC LIMIT 1\");\r\n\r\n        let newId;\r\n        if (lastCategory.length > 0) {\r\n            // Extract the number from the last ID and increment\r\n            const lastIdNumber = parseInt(lastCategory[0].Ca_Id.split(\"_\")[1], 10);\r\n            newId = `Ca_${String(lastIdNumber + 1).padStart(4, \"0\")}`;\r\n        } else {\r\n            // If no categories exist, start from Ca_0001\r\n            newId = \"Ca_0001\";\r\n        }\r\n\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO Category (Ca_Id, name) VALUES (?, ?)`;\r\n        const values = [newId, req.body.Catname];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Category added successfully\",\r\n            data: {\r\n                Ca_Id: newId,\r\n                name: req.body.Catname\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting category data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Sub category one and two with image\r\nrouter.post(\"/subcategory\", upload.fields([{ name: \"subcatone_img\" }, { name: \"subcattwo_img\" }]), async (req, res) => {\r\n    const { Ca_Id, sub_one, sub_two } = req.body;\r\n    const subcatone_img = req.files[\"subcatone_img\"] ? req.files[\"subcatone_img\"][0].buffer : null;\r\n    const subcattwo_img = req.files[\"subcattwo_img\"] ? req.files[\"subcattwo_img\"][0].buffer : null;\r\n\r\n    try {\r\n        // Generate ID for subCat_one\r\n        const sb_c_id = await generateNewId(\"subCat_one\", \"sb_c_id\", \"S1\");\r\n\r\n        // Insert into subCat_one\r\n        await db.query(\r\n            \"INSERT INTO subCat_one (sb_c_id, subcategory, Ca_Id, img) VALUES (?, ?, ?, ?)\",\r\n            [sb_c_id, sub_one, Ca_Id, subcatone_img]\r\n        );\r\n\r\n        let sb_cc_id = null;\r\n        if (sub_two !== \"None\" && subcattwo_img) {\r\n            // Generate ID for subCat_two\r\n            sb_cc_id = await generateNewId(\"subCat_two\", \"sb_cc_id\", \"S2\");\r\n\r\n            // Insert into subCat_two\r\n            await db.query(\r\n                \"INSERT INTO subCat_two (sb_cc_id, subcategory, sb_c_id, img) VALUES (?, ?, ?, ?)\",\r\n                [sb_cc_id, sub_two, sb_c_id, subcattwo_img]\r\n            );\r\n        }\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Sub-category added successfully\",\r\n            data: {\r\n                sb_c_id,\r\n                sub_one,\r\n                Ca_Id,\r\n                sb_cc_id: sb_cc_id || null,\r\n                sub_two: sb_cc_id ? sub_two : null,\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting sub-category data:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n//Save new item to supplier\r\nrouter.post(\"/add-supplier-item\", async (req, res) => {\r\n    try {\r\n        const { I_Id, s_ID, unit_cost } = req.body;\r\n        console.log(I_Id, s_ID, unit_cost);\r\n\r\n        // Validate input\r\n        if (!I_Id || !s_ID || !unit_cost) {\r\n            return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n        }\r\n\r\n        // Query to insert the supplier item\r\n        const query = `\r\n            INSERT INTO item_supplier (I_Id, s_ID, unit_cost)\r\n            VALUES (?, ?, ?)\r\n                ON DUPLICATE KEY UPDATE unit_cost = VALUES(unit_cost)\r\n        `;\r\n\r\n        await db.query(query, [I_Id, s_ID, unit_cost]);\r\n\r\n        return res.status(201).json({ success: true, message: \"Item added successfully\" });\r\n    } catch (error) {\r\n        console.error(\"Error adding supplier item:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Fetch all coupons\r\nrouter.get(\"/coupon-details\", async (req, res) => {\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                sc.cpID AS coupon_code,\r\n                sc.discount,\r\n                st.stID AS sales_team_id,\r\n                e.name AS employee_name\r\n            FROM sales_coupon sc\r\n                     JOIN sales_team st ON sc.stID = st.stID\r\n                     JOIN Employee e ON st.E_Id = e.E_Id\r\n        `;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No coupon details found\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Coupon details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching coupon details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching coupon details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Fetch all Delivery rates\r\nrouter.get(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        const query = `SELECT * FROM deli_rates`;\r\n\r\n        const [results] = await db.query(query);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No rates details found\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Rates details retrieved successfully\",\r\n            data: results,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching  details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching details\",\r\n            error: error.message,\r\n        });\r\n    }\r\n});\r\n\r\n// GET API to fetch delivery schedule by district\r\nrouter.get(\"/delivery-schedule\", async (req, res) => {\r\n    const { district } = req.query; // Get district from query parameter\r\n\r\n    if (!district) {\r\n        return res.status(400).json({ message: \"District is required\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch all delivery dates for the given district\r\n        const [result] = await db.query(\r\n            \"SELECT ds_date FROM delivery_schedule WHERE district = ?\",\r\n            [district]\r\n        );\r\n\r\n        if (result.length === 0) {\r\n            return res.status(404).json({ message: \"District not found\" });\r\n        }\r\n\r\n        // Format the dates correctly without timezone shifts\r\n        const upcomingDates = result\r\n            .map(row => {\r\n                // Ensure the date remains in IST (India Standard Time)\r\n                const date = new Date(row.ds_date);\r\n                date.setHours(0, 0, 0, 0); // Remove any possible time shifts\r\n\r\n                // Use toLocaleDateString('en-CA') to keep format as YYYY-MM-DD\r\n                const formattedDate = date.toLocaleDateString('en-CA');\r\n\r\n                return formattedDate;\r\n            })\r\n            .filter(date => {\r\n                const today = new Date().toLocaleDateString('en-CA');\r\n                return date >= today; // Keep today's date and all upcoming dates\r\n            })\r\n            .sort((a, b) => new Date(a) - new Date(b)); // Sort dates\r\n\r\n        if (upcomingDates.length === 0) {\r\n            return res.status(404).json({ message: \"No upcoming delivery dates available\" });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Upcoming delivery dates found\",\r\n            district: district,\r\n            upcomingDates: upcomingDates,\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery schedule:\", error.message);\r\n        return res.status(500).json({ message: \"Error fetching delivery schedule\" });\r\n    }\r\n});\r\n\r\n// Update change qty\r\nrouter.put(\"/change-quantity\", async (req, res) => {\r\n    const { orId, itemId, newQuantity, updatedPrice, booked } = req.body;\r\n    console.log(req.body);\r\n\r\n    // Validation: Check required fields\r\n    if (!orId || !itemId || newQuantity == null || updatedPrice == null) {\r\n        return res.status(400).json({ message: \"Missing required fields.\" });\r\n    }\r\n\r\n    try {\r\n        // Fetch current item quantities\r\n        const [currentItem] = await db.query(\r\n            \"SELECT bookedQty, availableQty FROM Item WHERE I_Id = ?\",\r\n            [itemId]\r\n        );\r\n        console.log(\"Current Item:\", currentItem);\r\n\r\n        if (!currentItem || currentItem.length === 0) {\r\n            return res.status(404).json({ message: \"Item not found.\" });\r\n        }\r\n\r\n        // Fetch current order quantity\r\n        const [currentOrder] = await db.query(\r\n            \"SELECT qty FROM Order_Detail WHERE orID = ? AND I_Id = ?\",\r\n            [orId, itemId]\r\n        );\r\n\r\n        if (!currentOrder || currentOrder.length === 0) {\r\n            return res.status(404).json({ message: \"Order detail not found.\" });\r\n        }\r\n\r\n        //  Correctly accessing the first row values\r\n        const qtyDifference = Number(newQuantity) - Number(currentOrder[0].qty);\r\n\r\n        let newBookedQty = Number(currentItem[0].bookedQty);\r\n        let newAvailableQty = Number(currentItem[0].availableQty);\r\n\r\n        if (booked) {\r\n            newBookedQty += qtyDifference;\r\n            newAvailableQty -= qtyDifference;\r\n\r\n            if (newAvailableQty < 0) {\r\n                return res.status(400).json({ message: \"Insufficient available quantity.\" });\r\n            }\r\n        }\r\n\r\n        // Update Order_Detail\r\n        await db.query(\r\n            \"UPDATE Order_Detail SET qty = ?, tprice = ? WHERE orID = ? AND I_Id = ?\",\r\n            [newQuantity, updatedPrice, orId, itemId]\r\n        );\r\n\r\n        // Only update booked_item and Item when booked is true\r\n        if (booked) {\r\n            await db.query(\r\n                \"UPDATE booked_item SET qty = ? WHERE orID = ? AND I_Id = ?\",\r\n                [newQuantity, orId, itemId]\r\n            );\r\n\r\n            await db.query(\r\n                \"UPDATE Item SET bookedQty = ?, availableQty = ? WHERE I_Id = ?\",\r\n                [newBookedQty, newAvailableQty, itemId]\r\n            );\r\n        }\r\n\r\n        // Success response\r\n        return res.status(200).json({ message: \"Quantity updated successfully.\" });\r\n    } catch (error) {\r\n        console.error(\"Error updating quantity:\", error.message);\r\n        return res.status(500).json({ message: \"Error updating quantity.\", error: error.message });\r\n    }\r\n});\r\n\r\n// save new stock in item update stock\r\nrouter.post(\"/get-stock-details\", async (req, res) => {\r\n    try {\r\n        // Ensure req.body is an array\r\n        if (!Array.isArray(req.body) || req.body.length === 0) {\r\n            return res.status(400).json({ error: \"Invalid request. Provide an array of item IDs.\" });\r\n        }\r\n\r\n        const itemIds = req.body.map(id => id.trim()); // Trim whitespace\r\n\r\n        // Construct dynamic SQL query with placeholders\r\n        const placeholders = itemIds.map(() => \"?\").join(\", \");\r\n        const sql = `\r\n            SELECT * FROM m_s_r_detail\r\n            WHERE I_Id IN (${placeholders})\r\n              AND status = 'Available'\r\n        `;\r\n\r\n        // Execute query\r\n        const [results] = await db.query(sql, itemIds);\r\n\r\n        if (results.length === 0) {\r\n            return res.status(404).json({\r\n                message: \"No stock details found for the provided item IDs\",\r\n                itemIds: itemIds,\r\n                stockDetails: []\r\n            });\r\n        }\r\n\r\n        return res.status(200).json({\r\n            message: \"Stock details retrieved successfully\",\r\n            itemIds: itemIds,\r\n            stockDetails: results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching stock details:\", error);\r\n        return res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n});\r\n\r\n// Issued order\r\nrouter.post(\"/isssued-order\", async (req, res) => {\r\n    const { orID, delStatus, delPrice, discount,subtotal, total, advance, balance, payStatus, stID, paymentAmount, selectedItems } = req.body;\r\n\r\n    console.log(req.body);\r\n\r\n    if (!orID || !stID || paymentAmount === undefined || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n    const IssuedPrice = parseFloat(paymentAmount);\r\n\r\n\r\n    try {\r\n        // 1. Update Orders table\r\n        await db.query(\r\n            `UPDATE Orders\r\n             SET delStatus = ?, orStatus = 'Issued', delPrice = ?, discount = ?, total = ?, advance = ?, balance = ?, payStatus = ?, stID = ?\r\n             WHERE OrID = ?`,\r\n            [delStatus, delPrice, discount, total, advance, balance, payStatus, stID, orID]\r\n        );\r\n\r\n        // 2. Update m_s_r_detail table (Mark selected items as issued)\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE m_s_r_detail\r\n                 SET status = 'Issued', orID = ?, datetime = NOW()\r\n                 WHERE srd_Id = ?`,\r\n                [orID, item.srd_Id]\r\n            );\r\n        }\r\n\r\n        // 3. Update sales_team table\r\n        await db.query(\r\n            `UPDATE sales_team\r\n             SET totalIssued = totalIssued + ?\r\n             WHERE stID = ?`,\r\n            [IssuedPrice, stID]\r\n        );\r\n\r\n        // 4. Update Item stock quantities using Order_Detail table\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        for (const item of orderItems) {\r\n            await db.query(\r\n                `UPDATE Item\r\n                 SET stockQty = stockQty - ?, bookedQty = bookedQty - ?\r\n                 WHERE I_Id = ?`,\r\n                [item.qty, item.qty, item.I_Id]\r\n            );\r\n        }\r\n\r\n        // 5. Delete from booked_item & accept_orders\r\n        await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n        await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n        // 6. Insert into Payment table\r\n        await db.query(\r\n            `INSERT INTO Payment (orID, amount, dateTime)\r\n             VALUES (?, ?, NOW())`,\r\n            [orID, paymentAmount]\r\n        );\r\n\r\n        return res.status(200).json({ success: true, message: \"Order updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Issued Orders items\r\nrouter.post(\"/isssued-items\", async (req, res) => {\r\n    const { orID, payStatus, selectedItems } = req.body;\r\n\r\n    console.log(req.body);\r\n\r\n    if (!orID || !payStatus || !selectedItems || selectedItems.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"Missing required fields\" });\r\n    }\r\n\r\n    try {\r\n        // 1. Update Orders table\r\n        await db.query(\r\n            `UPDATE Orders SET  orStatus = 'Issued', payStatus = ? WHERE OrID = ?`,\r\n            [ payStatus, orID]\r\n        );\r\n\r\n        // 2. Update m_s_r_detail table (Mark selected items as issued)\r\n        for (const item of selectedItems) {\r\n            await db.query(\r\n                `UPDATE m_s_r_detail\r\n                 SET status = 'Issued', orID = ?, datetime = NOW()\r\n                 WHERE srd_Id = ?`,\r\n                [orID, item.srd_Id]\r\n            );\r\n        }\r\n\r\n        // 4. Update Item stock quantities using Order_Detail table\r\n        const [orderItems] = await db.query(\r\n            `SELECT I_Id, qty FROM Order_Detail WHERE orID = ?`,\r\n            [orID]\r\n        );\r\n\r\n        for (const item of orderItems) {\r\n            await db.query(\r\n                `UPDATE Item\r\n                 SET stockQty = stockQty - ?, bookedQty = bookedQty - ?\r\n                 WHERE I_Id = ?`,\r\n                [item.qty, item.qty, item.I_Id]\r\n            );\r\n        }\r\n\r\n        // 5. Delete from booked_item & accept_orders\r\n        await db.query(`DELETE FROM booked_item WHERE orID = ?`, [orID]);\r\n        await db.query(`DELETE FROM accept_orders WHERE orID = ?`, [orID]);\r\n\r\n        return res.status(200).json({ success: true, message: \"Order updated successfully\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating order:\", error.message);\r\n        return res.status(500).json({ success: false, message: \"Server error\", error: error.message });\r\n    }\r\n});\r\n\r\n// Save new Delivery Rate\r\nrouter.post(\"/delivery-rates\", async (req, res) => {\r\n    try {\r\n        // SQL query to insert new category\r\n        const sql = `INSERT INTO deli_Rates (district, amount) VALUES (?, ?)`;\r\n        const values = [req.body.District,req.body.rate];\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, values);\r\n\r\n        // Return success response with the new category details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Rate added successfully\",\r\n            data: {\r\n                District: req.body.District,\r\n                rate: req.body.rate\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting rates data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save Scheduled dates\r\nrouter.post(\"/delivery-dates\", async (req, res) => {\r\n    try {\r\n        console.log(req.body);\r\n\r\n        const { District, dates } = req.body; // Extract district and dates array\r\n\r\n        if (!District || !Array.isArray(dates) || dates.length === 0) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"District and at least one date are required\"\r\n            });\r\n        }\r\n\r\n        // SQL query to insert multiple dates\r\n        const sql = `INSERT INTO delivery_schedule (district, ds_date) VALUES ?`;\r\n        const values = dates.map(date => [District, date]); // Create array of values\r\n\r\n        // Execute the insert query\r\n        await db.query(sql, [values]);\r\n\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Delivery dates added successfully\",\r\n            data: {\r\n                District,\r\n                dates,\r\n            },\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error inserting delivery dates:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save new employee and saleteam\r\nrouter.post(\"/employees\", async (req, res) => {\r\n    try {\r\n        const { name, address, nic, dob, contact, job, basic, orderTarget , issuedTarget } = req.body;\r\n        console.log(req.body);\r\n\r\n        if (!name || !address || !nic || !dob || !contact || !job || !basic ) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: \"All fields are required except target and currentRate (only for Sales).\"\r\n            });\r\n        }\r\n\r\n        const E_Id = await generateNewId(\"Employee\", \"E_Id\", \"E\"); // Generate new Employee ID\r\n\r\n        const sql = `INSERT INTO Employee (E_Id, name, address, nic, dob, contact, job, basic) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;\r\n        await db.query(sql, [E_Id, name, address, nic, dob, contact, job, basic]);\r\n\r\n        // If job is Sales, insert into sales_team table\r\n        let Data = null;\r\n        if (job === \"Sales\" && orderTarget && issuedTarget) {\r\n            const stID = await generateNewId(\"sales_team\", \"stID\", \"ST\");\r\n            const sqlSales = `INSERT INTO sales_team (stID, E_Id, orderTarget,issuedTarget, totalOrder, totalIssued) VALUES (?, ?, ?,?,'0', '0')`;\r\n            await db.query(sqlSales,[stID, E_Id, orderTarget , issuedTarget]);\r\n\r\n            Data = { stID, orderTarget , issuedTarget };\r\n        }\r\n        if ( job === \"Driver\"){\r\n            const devID = await generateNewId(\"driver\",\"devID\",\"DI\");\r\n            const sqlDriver = `INSERT INTO driver (devID,E_ID,balance) VALUES (?,?,'0')`;\r\n            await db.query(sqlDriver,[devID,E_Id]);\r\n\r\n            Data = {devID,E_Id};\r\n\r\n        }\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Employee added successfully\",\r\n            data:  {E_Id,Data},\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error adding employee:\", err);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error adding employee\",\r\n            details: err.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save Delivery Notes\r\nrouter.post(\"/create-delivery-note\", async (req, res) => {\r\n    try {\r\n        const { driverName,driverId, vehicleName, hire, date, district, orders, balanceToCollect } = req.body;\r\n        console.log(orders);\r\n\r\n        const delHire = parseFloat(hire);\r\n\r\n        // Validate required fields\r\n        if (!driverName || !vehicleName || !date || !hire || !orders || orders.length === 0) {\r\n            return res.status(400).json({ message: \"Driver name, vehicle name, hire, date, and orders are required.\" });\r\n        }\r\n\r\n        // Convert the date from DD/MM/YY format to YYYY-MM-DD\r\n        const [day, month, year] = date.split('/');\r\n        const formattedDate = `20${year.length === 2 ? year : year.slice(2)}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\r\n\r\n        // Insert into the delivery_note table\r\n        const [result] = await db.query(`\r\n            INSERT INTO delivery_note (driverName,devID, vehicalName, date, hire, district, balanceToCollect, status)\r\n            VALUES (?,?, ?, ?, ?, ?, ?, 'Incomplete')\r\n        `, [driverName,driverId, vehicleName, formattedDate, delHire, district, balanceToCollect]);\r\n\r\n        // Get the generated delNoID (Delivery Note ID)\r\n        const delNoID = result.insertId;\r\n\r\n        // Insert the orders into the delivery_note_orders table\r\n        const orderQueries = orders.map(({ orderId, balance }) => {\r\n            return db.query(`\r\n                INSERT INTO delivery_note_orders (delNoID, orID, balance)\r\n                VALUES (?, ?, ?)\r\n            `, [delNoID, orderId, balance]); // Now including balance\r\n        });\r\n\r\n        // Execute all insert queries in parallel\r\n        await Promise.all(orderQueries);\r\n\r\n        // Update delivery status for each order\r\n        const deliveryQueries = orders.map(({ orderId }) => {\r\n            return db.query(`\r\n                UPDATE delivery\r\n                SET status = 'Delivered', delivery_Date = ?\r\n                WHERE orID = ?\r\n            `, [formattedDate, orderId]);\r\n        });\r\n\r\n        // Execute all delivery updates in parallel\r\n        await Promise.all(deliveryQueries);\r\n\r\n        // Send success response\r\n        return res.status(201).json({\r\n            message: \"Delivery note and orders created successfully, and delivery status updated.\",\r\n            delNoID, // Return the generated Delivery Note ID\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error creating delivery note:\", error.message);\r\n        return res.status(500).json({ message: \"Error creating delivery note\", details: error.message });\r\n    }\r\n});\r\n\r\n// Get Delivery Note detail\r\nrouter.get(\"/delivery-note\", async (req, res) => {\r\n    try {\r\n        const { delNoID } = req.query;\r\n\r\n        if (!delNoID) {\r\n            return res.status(400).json({ success: false, message: \"Delivery Note ID is required.\" });\r\n        }\r\n\r\n        // Fetch delivery note details including driver ID (devID) and driver name from Employee\r\n        const [deliveryNote] = await db.query(\r\n            `SELECT dn.*, e.name AS driverName\r\n             FROM delivery_note dn\r\n                      LEFT JOIN driver d ON dn.devID = d.devID\r\n                      LEFT JOIN Employee e ON d.E_Id = e.E_Id\r\n             WHERE dn.delNoID = ?`,\r\n            [delNoID]\r\n        );\r\n\r\n        if (deliveryNote.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"Delivery note not found\" });\r\n        }\r\n\r\n        // Fetch associated orders and balance from delivery_note_orders\r\n        const [orders] = await db.query(\r\n            `SELECT o.OrID, o.orStatus AS orderStatus, o.delStatus AS deliveryStatus,\r\n                    o.payStatus, dno.balance AS balanceAmount\r\n             FROM delivery_note_orders dno\r\n                      INNER JOIN Orders o ON o.OrID = dno.orID\r\n             WHERE dno.delNoID = ?`,\r\n            [delNoID]\r\n        );\r\n\r\n        if (orders.length === 0) {\r\n            return res.status(404).json({ success: false, message: \"No orders found for this delivery note\" });\r\n        }\r\n\r\n        // Fetch issued items grouped by order ID\r\n        const orderIds = orders.map(order => order.OrID);\r\n        let issuedItems = [];\r\n\r\n        if (orderIds.length > 0) {\r\n            [issuedItems] = await db.query(\r\n                `SELECT m.orID, m.srd_Id, m.I_Id, m.stock_Id, m.barcode, m.datetime\r\n                 FROM m_s_r_detail m\r\n                 WHERE m.orID IN (?) AND m.status = 'Issued'`,\r\n                [orderIds]\r\n            );\r\n        }\r\n\r\n        // Organize issued items under their respective orders\r\n        const ordersWithIssuedItems = orders.map(order => ({\r\n            ...order,\r\n            issuedItems: issuedItems.filter(item => item.orID === order.OrID),\r\n            balance: order.payStatus === \"COD\" ? order.balanceAmount : null // Include balance only if COD\r\n        }));\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Delivery note details fetched successfully\",\r\n            details: deliveryNote[0], // Delivery note details including devID and driver name\r\n            orders: ordersWithIssuedItems // Orders with issued items grouped\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching delivery note details:\", error.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error fetching delivery note details\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Coupone\r\nrouter.post(\"/coupone\", async (req, res) => {\r\n    const sql = `INSERT INTO sales_coupon (cpID,stID,discount) VALUES (?, ?,?)`;\r\n    const values = [\r\n        req.body.couponCode,\r\n        req.body.saleteamCode,\r\n        req.body.discount\r\n    ];\r\n    try {\r\n        // Execute the query and retrieve the result\r\n        const [result] = await db.query(sql, values);\r\n\r\n        // Return success response with inserted data details\r\n        return res.status(201).json({\r\n            success: true,\r\n            message: \"Coupone added successfully\",\r\n            data: {\r\n                couponCode : req.body.couponCode,\r\n                saleteamCode: req.body.saleteamCode,\r\n                discount: req.body.discount\r\n            },\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error inserting coupone data:\", err.message);\r\n\r\n        // Respond with error details\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error inserting data into database\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Save New Promotion\r\nrouter.post(\"/promotion\", upload.single('img'), async (req, res) => {\r\n    const sql = `INSERT INTO Promotion (img, date ) VALUES (?, ?)`;\r\n\r\n    const values = [\r\n        req.file.buffer,  // The image file is in `req.file.buffer`\r\n        req.body.date,\r\n    ];\r\n    console.log(values);\r\n\r\n    // try {\r\n    //     const [result] = await db.query(sql, values);\r\n    //\r\n    //     return res.status(201).json({\r\n    //         success: true,\r\n    //         message: \"Promotion added successfully\",\r\n    //         data: {\r\n    //             img: req.body.img,\r\n    //             date: req.body.date,\r\n    //         },\r\n    //     });\r\n    // } catch (err) {\r\n    //     console.error(\"Error inserting item data:\", err.message);\r\n    //     return res.status(500).json({\r\n    //         success: false,\r\n    //         message: \"Error inserting data into database\",\r\n    //         details: err.message,\r\n    //     });\r\n    // }\r\n});\r\n\r\n// Update delivery note when order status issued (done)\r\nrouter.post(\"/delivery-done\", async (req, res) => {\r\n    const { updatedOrders, deliveryNoteId } = req.body; // Extract orders array and delivery note ID\r\n\r\n    if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"No valid orders provided.\" });\r\n    }\r\n\r\n    try {\r\n        for (const order of updatedOrders) {\r\n            console.log(order);\r\n            const { OrID, orderStatus, deliveryStatus, received, reason, reasonType, rescheduledDate } = order;\r\n            console.log(OrID);\r\n\r\n            // Ensure the order exists before updating\r\n            const [rows] = await db.query(\r\n                \"SELECT orID, custName, balance, payStatus, expectedDate, stID FROM Orders WHERE orID = ?\",\r\n                [OrID]\r\n            );\r\n\r\n            if (!rows || rows.length === 0) {\r\n                throw new Error(`Order ${OrID} not found.`);\r\n            }\r\n\r\n            const existingOrder = rows[0]; // Fix: Get the first row properly\r\n\r\n            const { orID, custName, balance, payStatus, expectedDate, stID } = existingOrder;\r\n            console.log(orID, custName, balance, payStatus, expectedDate, stID);\r\n\r\n            // Ensure balance is valid\r\n            const updatedBalance = parseFloat(balance) || 0;\r\n            console.log(updatedBalance);\r\n\r\n            // Uncomment this when testing is done\r\n            await db.query(`UPDATE Orders SET advance = ?, balance = ?, payStatus = ? WHERE OrID = ?`, [updatedBalance, 0, 'Settled', OrID]);\r\n            await db.query(`UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?`, [updatedBalance, stID]);\r\n            await db.query(`INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())`, [OrID, updatedBalance]);\r\n            await db.query(`UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?`, [\"Delivered\", expectedDate, OrID]);\r\n            await db.query(`UPDATE delivery_note SET status = ? WHERE delNoID = ?`, [\"Complete\", deliveryNoteId]);\r\n        }\r\n\r\n        return res.status(200).json({\r\n            success: true,\r\n            message: \"Orders updated successfully.\",\r\n        });\r\n\r\n    } catch (err) {\r\n        console.error(\"Error updating orders:\", err.message);\r\n        return res.status(500).json({\r\n            success: false,\r\n            message: \"Error updating orders\",\r\n            details: err.message,\r\n        });\r\n    }\r\n});\r\n\r\n// Update delivery note when order status issued (done)\r\n// router.post(\"/delivery-return\", async (req, res) => {\r\n//     const { updatedOrders, deliveryNoteId, driver } = req.body;\r\n//     if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {\r\n//         return res.status(400).json({ success: false, message: \"No valid orders provided.\" });\r\n//     }\r\n//     try {\r\n//         for (const order of updatedOrders) {\r\n//             const { OrID, orderStatus, reason, reasonType, rescheduledDate, returnedItems, paymentDetails } = order;\r\n//             const { RPayment, driverbalance, customerbalance } = paymentDetails || {};\r\n//             const receivedAmount = Number(RPayment) || 0;\r\n//             const DrivBalance = Number(driverbalance) || 0;\r\n//             const CustBalanc = Number(customerbalance) || 0;\r\n//             const CustBalance = Number(CustBalanc) * (-1);\r\n//\r\n//             // Fetch order details\r\n//             const [rows] = await db.query(\r\n//                 \"SELECT orID, c_ID, balance, advance, total, netTotal, discount, delPrice FROM Orders WHERE orID = ?\",\r\n//                 [OrID]\r\n//             );\r\n//\r\n//             if (!rows || rows.length === 0) {\r\n//                 throw new Error(`Order ${OrID} not found.`);\r\n//             }\r\n//\r\n//             const { balance, advance, total, discount, delPrice, c_ID } = rows[0];\r\n//\r\n//             // Fetch customer and driver details\r\n//             const [customerData] = await db.query(\"SELECT balance FROM Customer WHERE c_ID = ?\", [c_ID]);\r\n//             const customerBalance = Number(customerData[0]?.balance || 0) + CustBalance;\r\n//\r\n//             const [driverData] = await db.query(\"SELECT balance FROM Driver WHERE devID = ?\", [driver]);\r\n//             const driverNewBalance = Number(driverData[0]?.balance || 0) + DrivBalance;\r\n//\r\n//             // Calculate new order balance & advance\r\n//             const newAdvance = Number(advance || 0) + receivedAmount;\r\n//             const newBalance = Number(balance || 0) - receivedAmount;\r\n//\r\n//             console.log(\"Advance :\"+newAdvance+\"  Balance :\"+newBalance);\r\n//             console.log(\"Customer :\"+customerBalance+\"  Driver :\"+DrivBalance);\r\n//             for (const item of returnedItems) {\r\n//                 console.log(item);\r\n//             }\r\n//             if (orderStatus === \"Issued\" || orderStatus === \"Returned\" || orderStatus === \"Cancelled\") {\r\n//                 console.log(`${orderStatus} order processing...`);\r\n//\r\n//                 let payStatus = newBalance === 0 ? \"Settled\" : \"N-Settled\";\r\n//                 await db.query(\r\n//                     \"UPDATE Orders SET advance = ?, balance = ?, payStatus = ?, orStatus = ? WHERE OrID = ?\",\r\n//                     [newAdvance, newBalance, payStatus, orderStatus, OrID]\r\n//                 );\r\n//\r\n//                 await db.query(\"UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?\", [orderStatus, rescheduledDate || rows[0].expectedDate, OrID]);\r\n//\r\n//                 if (orderStatus === \"Returned\" || orderStatus === \"Cancelled\") {\r\n//                     for (const item of returnedItems) {\r\n//                         await db.query(\"UPDATE m_s_r_detail SET status = ?, datetime = NOW() WHERE stock_Id = ? AND I_Id = ?\",\r\n//                             [item.status, item.stockId, item.itemId]);\r\n//                         const [price] = await db.query(\"SELECT price FROM Item WHERE I_Id = ?\", [item.itemId]);\r\n//                     }\r\n//                     const reasonTable = orderStatus === \"Returned\" ? \"return_orders\" : \"canceled_orders\";\r\n//                     await db.query(`INSERT INTO ${reasonTable} (orID, detail) VALUES (?, ?)`, [OrID, reason]);\r\n//                 }\r\n//             }\r\n//             await db.query(\"UPDATE Driver SET balance = ? WHERE devID = ?\", [driverNewBalance, driver]);\r\n//             await db.query(\"UPDATE Customer SET balance = ? WHERE c_ID = ?\", [customerBalance, c_ID]);\r\n//             await db.query(\"INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())\", [OrID, receivedAmount]);\r\n//             await db.query(\"UPDATE delivery_note SET status = ? WHERE delNoID = ?\", [\"Complete\", deliveryNoteId]);\r\n//         }\r\n//         return res.status(200).json({ success: true, message: \"Orders updated successfully.\" });\r\n//     } catch (err) {\r\n//         console.error(\"Error updating orders:\", err.message);\r\n//         return res.status(500).json({ success: false, message: \"Error updating orders\", details: err.message });\r\n//     }\r\n// });\r\nrouter.post(\"/delivery-return\", async (req, res) => {\r\n    const { updatedOrders, deliveryNoteId, driver } = req.body;\r\n    if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {\r\n        return res.status(400).json({ success: false, message: \"No valid orders provided.\" });\r\n    }\r\n    try {\r\n        for (const order of updatedOrders) {\r\n            const { OrID, orderStatus, reason, reasonType, rescheduledDate, returnedItems, paymentDetails } = order;\r\n            const { RPayment, driverbalance, customerbalance } = paymentDetails || {};\r\n            const receivedAmount = Number(RPayment) || 0;\r\n            const DrivBalance = Number(driverbalance) || 0;\r\n            const CustBalanc = Number(customerbalance) || 0;\r\n            const CustBalance = Number(CustBalanc) * (-1);\r\n\r\n            // Fetch order details\r\n            const [rows] = await db.query(\r\n                \"SELECT orID, c_ID, balance, advance, total, netTotal, discount, delPrice FROM Orders WHERE orID = ?\",\r\n                [OrID]\r\n            );\r\n\r\n            if (!rows || rows.length === 0) {\r\n                throw new Error(`Order ${OrID} not found.`);\r\n            }\r\n\r\n            const { balance, advance, total, discount, delPrice, c_ID } = rows[0];\r\n\r\n            // Fetch customer and driver details\r\n            const [customerData] = await db.query(\"SELECT balance FROM Customer WHERE c_ID = ?\", [c_ID]);\r\n            const customerBalance = Number(customerData[0]?.balance || 0) + CustBalance;\r\n\r\n            const [driverData] = await db.query(\"SELECT balance FROM Driver WHERE devID = ?\", [driver]);\r\n            const driverNewBalance = Number(driverData[0]?.balance || 0) + DrivBalance;\r\n\r\n            // Calculate new order balance & advance\r\n            const newAdvance = Number(advance || 0) + receivedAmount;\r\n            const newBalance = Number(balance || 0) - receivedAmount;\r\n\r\n            console.log(\"Advance :\" + newAdvance + \"  Balance :\" + newBalance);\r\n            console.log(\"Customer :\" + customerBalance + \"  Driver :\" + DrivBalance);\r\n            for (const item of returnedItems) {\r\n                console.log(item);\r\n            }\r\n            if (orderStatus === \"Issued\" || orderStatus === \"Returned\" || orderStatus === \"Cancelled\") {\r\n                console.log(`${orderStatus} order processing...`);\r\n\r\n                let payStatus = newBalance === 0 ? \"Settled\" : \"N-Settled\";\r\n                await db.query(\r\n                    \"UPDATE Orders SET advance = ?, balance = ?, payStatus = ?, orStatus = ? WHERE OrID = ?\",\r\n                    [newAdvance, newBalance, payStatus, orderStatus, OrID]\r\n                );\r\n\r\n                await db.query(\"UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?\", [orderStatus, rescheduledDate || rows[0].expectedDate, OrID]);\r\n\r\n                if (orderStatus === \"Returned\" || orderStatus === \"Cancelled\") {\r\n                    for (const item of returnedItems) {\r\n                        await db.query(\"UPDATE m_s_r_detail SET status = ?, datetime = NOW() WHERE stock_Id = ? AND I_Id = ?\",\r\n                            [item.status, item.stockId, item.itemId]);\r\n                        const [price] = await db.query(\"SELECT price FROM Item WHERE I_Id = ?\", [item.itemId]);\r\n                    }\r\n                    const reasonTable = orderStatus === \"Returned\" ? \"return_orders\" : \"canceled_orders\";\r\n                    await db.query(`INSERT INTO ${reasonTable} (orID, detail) VALUES (?, ?)`, [OrID, reason]);\r\n                }\r\n            }\r\n            await db.query(\"UPDATE Driver SET balance = ? WHERE devID = ?\", [driverNewBalance, driver]);\r\n            await db.query(\"UPDATE Customer SET balance = ? WHERE c_ID = ?\", [customerBalance, c_ID]);\r\n            await db.query(\"INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())\", [OrID, receivedAmount]);\r\n            await db.query(\"UPDATE delivery_note SET status = ? WHERE delNoID = ?\", [\"Complete\", deliveryNoteId]);\r\n        }\r\n        return res.status(200).json({ success: true, message: \"Orders updated successfully.\" });\r\n    } catch (err) {\r\n        console.error(\"Error updating orders:\", err.message);\r\n        return res.status(500).json({ success: false, message: \"Error updating orders\", details: err.message });\r\n    }\r\n});\r\n\r\n\r\n// update payment in delivery note\r\nrouter.post(\"/delivery-payment\", async (req, res) => {\r\n    const { orderid, payment, driver, RPayment, driverbalance, customerbalance } = req.body;\r\n    const receivedPayment = parseFloat(RPayment) || 0;\r\n    const DrivBalance = parseFloat(driverbalance) || 0;\r\n    const CustBalance = parseFloat(customerbalance) || 0;\r\n\r\n    try {\r\n        // Fetch order details\r\n        const [Orderpayment] = await db.query(\r\n            \"SELECT custName, contact1, contact2, advance, balance, stID FROM Orders WHERE OrID = ?\",\r\n            [orderid]\r\n        );\r\n\r\n        if (!Orderpayment || Orderpayment.length === 0) {\r\n            console.error(\"No order found for this order ID.\");\r\n            return res.status(404).json({ error: \"Order not found.\" });\r\n        }\r\n\r\n        const { contact1, contact2, stID } = Orderpayment[0];\r\n\r\n        // Fetch customer\r\n        const [customer] = await db.query(\r\n            \"SELECT c_ID, credit FROM Customer WHERE contact1 = ? OR contact2 = ? OR (contact1 = ? AND contact2 = ?)\",\r\n            [contact1, contact1, contact2, contact2]\r\n        );\r\n\r\n        if (!customer || customer.length === 0) {\r\n            console.error(\"No customer found with these contact details.\");\r\n            return res.status(404).json({ error: \"Customer not found.\" });\r\n        }\r\n\r\n        const cid = customer[0].c_ID;\r\n        console.log(\"Customer Found: \", cid);\r\n\r\n        // Fetch Employee\r\n        const [EMPID] = await db.query(\"SELECT E_Id FROM Employee WHERE name=?\", [driver]);\r\n\r\n        if (!EMPID || EMPID.length === 0) {\r\n            console.error(\"No employee found with the name:\", driver);\r\n            return res.status(404).json({ error: \"Employee not found.\" });\r\n        }\r\n\r\n        const employeeId = EMPID[0].E_Id;\r\n        console.log(\"Employee ID Found:\", employeeId);\r\n\r\n        // Fetch Driver\r\n        const [driverData] = await db.query(\"SELECT devID, balance FROM driver WHERE E_ID=?\", [employeeId]);\r\n\r\n        if (!driverData || driverData.length === 0) {\r\n            console.error(\"No driver found for employee ID:\", employeeId);\r\n            return res.status(404).json({ error: \"Driver not found.\" });\r\n        }\r\n\r\n        const dId = driverData[0].devID;\r\n        console.log(\"Driver ID Found:\", dId);\r\n\r\n        // Safely parse values, ensuring no NaN or undefined values\r\n        const advance = parseFloat(Orderpayment[0]?.advance || 0) + receivedPayment;\r\n        const balance = parseFloat(Orderpayment[0]?.balance || 0) - receivedPayment;\r\n        const creditBalance = parseFloat(customer[0]?.credit || 0) + CustBalance;\r\n        const driverBalance = parseFloat(driverData[0]?.balance || 0) + DrivBalance;\r\n\r\n        console.log(\"Updated Values:\");\r\n        console.log(\"New Order Advance:\", advance);\r\n        console.log(\"New Order Balance:\", balance);\r\n        console.log(\"New Customer Credit Balance:\", creditBalance);\r\n        console.log(\"New Driver Balance:\", driverBalance);\r\n\r\n        // Update Order Payment Status\r\n        const payStatus = balance === 0 ? 'Settled' : 'Credit';\r\n        await db.query(\r\n            \"UPDATE Orders SET advance = ?, balance = ?, payStatus = ? WHERE OrID = ?\",\r\n            [advance, balance, payStatus, orderid]\r\n        );\r\n\r\n        // Update Sales Team Record\r\n        await db.query(\"UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?\", [receivedPayment, stID]);\r\n\r\n        // Insert Payment Record\r\n        await db.query(\"INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())\", [orderid, receivedPayment]);\r\n\r\n        // Update Driver Balance\r\n        await db.query(\"UPDATE driver SET balance = balance + ? WHERE devID = ?\", [DrivBalance, dId]);\r\n\r\n        // Update Customer Credit Balance\r\n        await db.query(\"UPDATE Customer SET credit = ? WHERE c_ID = ?\", [creditBalance, cid]);\r\n\r\n        // Update delivery_note_order Balance\r\n        await db.query(\"UPDATE delivery_note_orders SET balance = ? WHERE orID = ?\", [balance, orderid]);\r\n\r\n        res.json({ success: true, message: \"Payment processed successfully.\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error processing delivery payment:\", error);\r\n        res.status(500).json({ error: \"Internal server error\" });\r\n    }\r\n});\r\n\r\n// get delivery schdule by date\r\nrouter.get(\"/check-delivery\", async (req, res) => {\r\n    const { date } = req.query; // Get date from query parameter\r\n    console.log(date);\r\n\r\n    if (!date) {\r\n        return res.status(400).json({ message: \"Date is required\" });\r\n    }\r\n\r\n    try {\r\n        // Check if the given date is already scheduled for delivery\r\n        const [result] = await db.query(\r\n            \"SELECT COUNT(*) AS count FROM delivery_schedule WHERE ds_date = ?\",\r\n            [date]\r\n        );\r\n        console.log(result);\r\n\r\n        // Reverse the logic: if count is 0, delivery is available; otherwise, it's not available\r\n        const available = result[0].count === 0;\r\n\r\n        return res.status(200).json({\r\n            message: available ? \"Delivery available\" : \"No delivery available on this date\",\r\n            available: available\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error checking delivery availability:\", error.message);\r\n        return res.status(500).json({ message: \"Error checking delivery availability\" });\r\n    }\r\n});\r\n\r\n// Function to generate new ida\r\nconst generateNewId = async (table, column, prefix) => {\r\n    const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);\r\n    if (rows.length === 0) return `${prefix}_001`; // First entry\r\n    const lastId = rows[0][column]; // Get last ID\r\n    console.log(lastId);\r\n    const lastNum = parseInt(lastId.split(\"_\")[1],10) + 1; // Extract number and increment\r\n    console.log(lastNum);\r\n    console.log(`${prefix}_${String(lastNum).padStart(3, \"0\")}`);\r\n    return `${prefix}_${String(lastNum).padStart(3, \"0\")}`;\r\n};\r\n\r\n// Helper function to parse date from DD/MM/YYYY format to YYYY-MM-DD format\r\nconst parseDate = (dateStr) => {\r\n    if (!dateStr) return null;\r\n\r\n    let year, month, day;\r\n\r\n    // Check if the date is in `YYYY-MM-DD` format\r\n    if (dateStr.includes(\"-\")) {\r\n        [year, month, day] = dateStr.split(\"-\");\r\n    }\r\n    // Check if the date is in `DD/MM/YYYY` format\r\n    else if (dateStr.includes(\"/\")) {\r\n        [day, month, year] = dateStr.split(\"/\");\r\n    } else {\r\n        return null; // Invalid format\r\n    }\r\n\r\n    // Validate components\r\n    if (!day || !month || !year || isNaN(day) || isNaN(month) || isNaN(year)) {\r\n        return null;\r\n    }\r\n\r\n    // Convert to `YYYY-MM-DD` for MySQL queries\r\n    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\r\n};\r\n\r\nconst formatDate = (date) => {\r\n    return date ? new Date(date).toLocaleDateString(\"en-GB\") : null;\r\n};\r\n\r\nexport default router;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/adminBackend/Routes/mainRoutes.js b/adminBackend/Routes/mainRoutes.js
--- a/adminBackend/Routes/mainRoutes.js	(revision ac82bf7ba11053196959c3a5d153fda8ba2fd20d)
+++ b/adminBackend/Routes/mainRoutes.js	(date 1742128309563)
@@ -3712,6 +3712,10 @@
                  WHERE srd_Id = ?`,
                 [orID, item.srd_Id]
             );
+            await db.query(
+                `INSERT INTO issued_items (orID,srd_Id,status) VALUES (?,?,'Issued')`,
+                [orID, item.srd_Id]
+            );
         }
 
         // 4. Update Item stock quantities using Order_Detail table
@@ -3866,60 +3870,75 @@
 // Save Delivery Notes
 router.post("/create-delivery-note", async (req, res) => {
     try {
-        const { driverName,driverId, vehicleName, hire, date, district, orders, balanceToCollect } = req.body;
-        console.log(orders);
+        console.log("Received request body:", req.body);
+
+        const { driverName, driverId, vehicleName, hire, date, district, orders, balanceToCollect } = req.body;
 
-        const delHire = parseFloat(hire);
+        // Debugging logs
+        console.log("Received orders:", orders);
 
         // Validate required fields
-        if (!driverName || !vehicleName || !date || !hire || !orders || orders.length === 0) {
+        if (!driverName || !vehicleName || !date || !hire || !Array.isArray(orders) || orders.length === 0) {
             return res.status(400).json({ message: "Driver name, vehicle name, hire, date, and orders are required." });
         }
 
-        // Convert the date from DD/MM/YY format to YYYY-MM-DD
-        const [day, month, year] = date.split('/');
-        const formattedDate = `20${year.length === 2 ? year : year.slice(2)}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
+        // if (!date || !date.includes('/')) {
+        //     return res.status(400).json({ message: "Invalid date format. Expected DD/MM/YY." });
+        // }
+        //
+        // const delHire = parseFloat(hire);
+        //
+        // // Convert date from DD/MM/YY to YYYY-MM-DD
+        // const [day, month, year] = date.split('-');
+        // const formattedDate = `20${year.length === 2 ? year : year.slice(2)}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
 
-        // Insert into the delivery_note table
+        // Insert into delivery_note table
         const [result] = await db.query(`
-            INSERT INTO delivery_note (driverName,devID, vehicalName, date, hire, district, balanceToCollect, status)
-            VALUES (?,?, ?, ?, ?, ?, ?, 'Incomplete')
-        `, [driverName,driverId, vehicleName, formattedDate, delHire, district, balanceToCollect]);
+            INSERT INTO delivery_note (driverName, devID, vehicalName, date, hire, district, balanceToCollect, status)
+            VALUES (?, ?, ?, ?, ?, ?, ?, 'Incomplete')
+        `, [driverName, driverId, vehicleName, date, hire, district, balanceToCollect]);
 
-        // Get the generated delNoID (Delivery Note ID)
+        // Get the generated Delivery Note ID
         const delNoID = result.insertId;
+        console.log("Generated Delivery Note ID:", delNoID);
 
-        // Insert the orders into the delivery_note_orders table
-        const orderQueries = orders.map(({ orderId, balance }) => {
-            return db.query(`
-                INSERT INTO delivery_note_orders (delNoID, orID, balance)
-                VALUES (?, ?, ?)
-            `, [delNoID, orderId, balance]); // Now including balance
+        // Insert orders into delivery_note_orders table
+        const orderQueries = orders.map(async ({ orderId, balance = 0 }) => {
+            try {
+                return await db.query(`
+                    INSERT INTO delivery_note_orders (delNoID, orID, balance)
+                    VALUES (?, ?, ?)
+                `, [delNoID, orderId, balance]);
+            } catch (err) {
+                console.error(`Error inserting order ${orderId}:`, err);
+            }
         });
-
-        // Execute all insert queries in parallel
-        await Promise.all(orderQueries);
 
         // Update delivery status for each order
-        const deliveryQueries = orders.map(({ orderId }) => {
-            return db.query(`
-                UPDATE delivery
-                SET status = 'Delivered', delivery_Date = ?
-                WHERE orID = ?
-            `, [formattedDate, orderId]);
+        const deliveryQueries = orders.map(async ({ orderId }) => {
+            try {
+                return await db.query(`
+                    UPDATE delivery
+                    SET status = 'Delivered', delivery_Date = ?
+                    WHERE orID = ?
+                `, [date, orderId]);
+            } catch (err) {
+                console.error(`Error updating delivery for order ${orderId}:`, err);
+            }
         });
 
-        // Execute all delivery updates in parallel
-        await Promise.all(deliveryQueries);
+        // Execute all insert and update queries
+        await Promise.allSettled(orderQueries);
+        await Promise.allSettled(deliveryQueries);
 
         // Send success response
         return res.status(201).json({
-            message: "Delivery note and orders created successfully, and delivery status updated.",
-            delNoID, // Return the generated Delivery Note ID
+            message: "Delivery note created successfully",
+            delNoID
         });
 
     } catch (error) {
-        console.error("Error creating delivery note:", error.message);
+        console.error("Error creating delivery note:", error);
         return res.status(500).json({ message: "Error creating delivery note", details: error.message });
     }
 });
@@ -3961,15 +3980,17 @@
             return res.status(404).json({ success: false, message: "No orders found for this delivery note" });
         }
 
-        // Fetch issued items grouped by order ID
+        // Fetch issued and returned items from the issued_items table
         const orderIds = orders.map(order => order.OrID);
         let issuedItems = [];
 
         if (orderIds.length > 0) {
             [issuedItems] = await db.query(
-                `SELECT m.orID, m.srd_Id, m.I_Id, m.stock_Id, m.barcode, m.datetime
-                 FROM m_s_r_detail m
-                 WHERE m.orID IN (?) AND m.status = 'Issued'`,
+                `SELECT ii.orID, ii.srd_Id, ii.status AS itemStatus, 
+                        msrd.stock_Id, msrd.barcode, msrd.datetime, msrd.I_Id
+                 FROM issued_items ii
+                 JOIN m_s_r_detail msrd ON ii.srd_Id = msrd.srd_Id
+                 WHERE ii.orID IN (?)`,
                 [orderIds]
             );
         }
@@ -3985,7 +4006,7 @@
             success: true,
             message: "Delivery note details fetched successfully",
             details: deliveryNote[0], // Delivery note details including devID and driver name
-            orders: ordersWithIssuedItems // Orders with issued items grouped
+            orders: ordersWithIssuedItems // Orders with issued and returned items grouped
         });
 
     } catch (error) {
@@ -4120,6 +4141,7 @@
 });
 
 // Update delivery note when order status issued (done)
+
 // router.post("/delivery-return", async (req, res) => {
 //     const { updatedOrders, deliveryNoteId, driver } = req.body;
 //     if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {
@@ -4195,84 +4217,35 @@
 //     }
 // });
 router.post("/delivery-return", async (req, res) => {
-    const { updatedOrders, deliveryNoteId, driver } = req.body;
-    if (!updatedOrders || !Array.isArray(updatedOrders) || updatedOrders.length === 0) {
-        return res.status(400).json({ success: false, message: "No valid orders provided." });
+    const { deliveryNoteId } = req.body;
+
+    if (!deliveryNoteId) {
+        return res.status(400).json({ error: "Missing deliveryNoteId in request body." });
     }
+
     try {
-        for (const order of updatedOrders) {
-            const { OrID, orderStatus, reason, reasonType, rescheduledDate, returnedItems, paymentDetails } = order;
-            const { RPayment, driverbalance, customerbalance } = paymentDetails || {};
-            const receivedAmount = Number(RPayment) || 0;
-            const DrivBalance = Number(driverbalance) || 0;
-            const CustBalanc = Number(customerbalance) || 0;
-            const CustBalance = Number(CustBalanc) * (-1);
-
-            // Fetch order details
-            const [rows] = await db.query(
-                "SELECT orID, c_ID, balance, advance, total, netTotal, discount, delPrice FROM Orders WHERE orID = ?",
-                [OrID]
-            );
+        const [result] = await db.query(
+            "UPDATE delivery_note SET status = ? WHERE delNoID = ?",
+            ["Complete", deliveryNoteId]
+        );
 
-            if (!rows || rows.length === 0) {
-                throw new Error(`Order ${OrID} not found.`);
-            }
-
-            const { balance, advance, total, discount, delPrice, c_ID } = rows[0];
-
-            // Fetch customer and driver details
-            const [customerData] = await db.query("SELECT balance FROM Customer WHERE c_ID = ?", [c_ID]);
-            const customerBalance = Number(customerData[0]?.balance || 0) + CustBalance;
-
-            const [driverData] = await db.query("SELECT balance FROM Driver WHERE devID = ?", [driver]);
-            const driverNewBalance = Number(driverData[0]?.balance || 0) + DrivBalance;
-
-            // Calculate new order balance & advance
-            const newAdvance = Number(advance || 0) + receivedAmount;
-            const newBalance = Number(balance || 0) - receivedAmount;
-
-            console.log("Advance :" + newAdvance + "  Balance :" + newBalance);
-            console.log("Customer :" + customerBalance + "  Driver :" + DrivBalance);
-            for (const item of returnedItems) {
-                console.log(item);
-            }
-            if (orderStatus === "Issued" || orderStatus === "Returned" || orderStatus === "Cancelled") {
-                console.log(`${orderStatus} order processing...`);
-
-                let payStatus = newBalance === 0 ? "Settled" : "N-Settled";
-                await db.query(
-                    "UPDATE Orders SET advance = ?, balance = ?, payStatus = ?, orStatus = ? WHERE OrID = ?",
-                    [newAdvance, newBalance, payStatus, orderStatus, OrID]
-                );
-
-                await db.query("UPDATE delivery SET status = ?, delivery_Date = ? WHERE orID = ?", [orderStatus, rescheduledDate || rows[0].expectedDate, OrID]);
+        if (result.affectedRows === 0) {
+            return res.status(404).json({ error: "Delivery note not found or already updated." });
+        }
 
-                if (orderStatus === "Returned" || orderStatus === "Cancelled") {
-                    for (const item of returnedItems) {
-                        await db.query("UPDATE m_s_r_detail SET status = ?, datetime = NOW() WHERE stock_Id = ? AND I_Id = ?",
-                            [item.status, item.stockId, item.itemId]);
-                        const [price] = await db.query("SELECT price FROM Item WHERE I_Id = ?", [item.itemId]);
-                    }
-                    const reasonTable = orderStatus === "Returned" ? "return_orders" : "canceled_orders";
-                    await db.query(`INSERT INTO ${reasonTable} (orID, detail) VALUES (?, ?)`, [OrID, reason]);
-                }
-            }
-            await db.query("UPDATE Driver SET balance = ? WHERE devID = ?", [driverNewBalance, driver]);
-            await db.query("UPDATE Customer SET balance = ? WHERE c_ID = ?", [customerBalance, c_ID]);
-            await db.query("INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())", [OrID, receivedAmount]);
-            await db.query("UPDATE delivery_note SET status = ? WHERE delNoID = ?", ["Complete", deliveryNoteId]);
-        }
-        return res.status(200).json({ success: true, message: "Orders updated successfully." });
-    } catch (err) {
-        console.error("Error updating orders:", err.message);
-        return res.status(500).json({ success: false, message: "Error updating orders", details: err.message });
+        return res.status(200).json({ success: true, message: "Delivery note updated successfully." });
+    } catch (error) {
+        console.error("Error updating delivery note:", error);
+        return res.status(500).json({ error: "Internal server error." });
     }
 });
 
 
 // update payment in delivery note
 router.post("/delivery-payment", async (req, res) => {
-    const { orderid, payment, driver, RPayment, driverbalance, customerbalance } = req.body;
+    const {customReason, deliveryStatus, driver, driverId, deliveryDate, orderId, orderStatus, paymentDetails, reason, rescheduledDate, returnedItems} = req.body;
+
+    const { RPayment, customerbalance, driverbalance } = paymentDetails || {};
     const receivedPayment = parseFloat(RPayment) || 0;
     const DrivBalance = parseFloat(driverbalance) || 0;
     const CustBalance = parseFloat(customerbalance) || 0;
@@ -4280,86 +4253,161 @@
     try {
         // Fetch order details
         const [Orderpayment] = await db.query(
-            "SELECT custName, contact1, contact2, advance, balance, stID FROM Orders WHERE OrID = ?",
-            [orderid]
+            "SELECT orID, c_ID, balance, advance, total, netTotal, discount, delPrice, stID FROM Orders WHERE OrID = ?",
+            [orderId]
         );
 
-        if (!Orderpayment || Orderpayment.length === 0) {
+        if (!Orderpayment) {
             console.error("No order found for this order ID.");
             return res.status(404).json({ error: "Order not found." });
         }
 
-        const { contact1, contact2, stID } = Orderpayment[0];
-
-        // Fetch customer
-        const [customer] = await db.query(
-            "SELECT c_ID, credit FROM Customer WHERE contact1 = ? OR contact2 = ? OR (contact1 = ? AND contact2 = ?)",
-            [contact1, contact1, contact2, contact2]
-        );
+        // Ensure all values are numeric
+        const {orID, c_ID, balance, advance, total , netTotal , discount , delPrice , stID} = Orderpayment[0];
 
-        if (!customer || customer.length === 0) {
-            console.error("No customer found with these contact details.");
-            return res.status(404).json({ error: "Customer not found." });
-        }
+        let NetTotal1 = parseFloat(netTotal) || 0;
+        let totalAmount = parseFloat(total) || 0;
+        let discountAmount = parseFloat(discount) || 0;
+        let deliveryCharge = parseFloat(delPrice) || 0;
 
-        const cid = customer[0].c_ID;
-        console.log("Customer Found: ", cid);
+        // Fetch delivery details
+        const [deliveryData] = await db.query("SELECT dv_id FROM delivery WHERE orID = ?", [orderId]);
+        const dv_id = deliveryData?.[0]?.dv_id || null;
 
-        // Fetch Employee
-        const [EMPID] = await db.query("SELECT E_Id FROM Employee WHERE name=?", [driver]);
+        // Fetch customer balance
+        const [customerData] = await db.query("SELECT balance FROM Customer WHERE c_ID = ?", [c_ID]);
+        let customerBalance = parseFloat(customerData?.[0]?.balance || 0) + CustBalance;
 
-        if (!EMPID || EMPID.length === 0) {
-            console.error("No employee found with the name:", driver);
-            return res.status(404).json({ error: "Employee not found." });
-        }
+        // Fetch driver balance
+        const [driverData] = await db.query("SELECT balance FROM Driver WHERE devID = ?", [driver]);
+        let driverNewBalance = parseFloat(driverData?.[0]?.balance || 0) + DrivBalance;
 
-        const employeeId = EMPID[0].E_Id;
-        console.log("Employee ID Found:", employeeId);
-
-        // Fetch Driver
-        const [driverData] = await db.query("SELECT devID, balance FROM driver WHERE E_ID=?", [employeeId]);
-
-        if (!driverData || driverData.length === 0) {
-            console.error("No driver found for employee ID:", employeeId);
-            return res.status(404).json({ error: "Driver not found." });
-        }
-
-        const dId = driverData[0].devID;
-        console.log("Driver ID Found:", dId);
-
-        // Safely parse values, ensuring no NaN or undefined values
-        const advance = parseFloat(Orderpayment[0]?.advance || 0) + receivedPayment;
-        const balance = parseFloat(Orderpayment[0]?.balance || 0) - receivedPayment;
-        const creditBalance = parseFloat(customer[0]?.credit || 0) + CustBalance;
-        const driverBalance = parseFloat(driverData[0]?.balance || 0) + DrivBalance;
+        // Update order advance & balance
+        const advance1 = parseFloat(advance) + receivedPayment;
+        const balance1 = parseFloat(totalAmount) - receivedPayment;
 
         console.log("Updated Values:");
-        console.log("New Order Advance:", advance);
-        console.log("New Order Balance:", balance);
-        console.log("New Customer Credit Balance:", creditBalance);
-        console.log("New Driver Balance:", driverBalance);
+        console.log("Total:", totalAmount);
+        console.log("New Order Advance:", advance1);
+        console.log("New Order Balance:", balance1);
+        console.log("New Customer Credit Balance:", customerBalance);
+        console.log("New Driver Balance:", driverNewBalance);
+
+        // Process returned items
+        if (returnedItems && Array.isArray(returnedItems)) {
+            for (const item of returnedItems) {
+                if (!item.itemId || !item.stockId) continue;
+
+                const [price] = await db.query("SELECT price FROM Item WHERE I_Id = ?", [item.itemId]);
+                if (price?.[0]?.price) {
+                    const itemPrice = parseFloat(price[0].price);
+                    NetTotal1 -= itemPrice;
+                    console.log(`Price of returned item (ID: ${item.itemId}): Rs. ${itemPrice}`);
+                }
+            }
+        }
+
+        // Ensure NetTotal1 is valid
+        NetTotal1 = isNaN(NetTotal1) ? 0 : NetTotal1;
 
-        // Update Order Payment Status
-        const payStatus = balance === 0 ? 'Settled' : 'Credit';
+        let newTotal = 0;
+        let reducePrice = 0;
+
+        if (NetTotal1 === 0) {
+            newTotal = (NetTotal1 - discountAmount) + deliveryCharge;
+            reducePrice = newTotal - totalAmount;
+            customerBalance += receivedPayment;
+        } else {
+            newTotal = (NetTotal1 - discountAmount) + deliveryCharge;
+            reducePrice = newTotal - totalAmount;
+            customerBalance += reducePrice;
+        }
+
+        // Ensure customer balance is valid
+        customerBalance = isNaN(customerBalance) ? 0 : customerBalance;
+
+        console.log("New Order Total:", newTotal);
+        console.log("Reduced Price:", reducePrice);
+        console.log("Updated Customer Credit Balance:", customerBalance);
+
+        // Update customer balance
         await db.query(
-            "UPDATE Orders SET advance = ?, balance = ?, payStatus = ? WHERE OrID = ?",
-            [advance, balance, payStatus, orderid]
+            "UPDATE Customer SET balance = ? WHERE c_ID = ?",
+            [customerBalance, c_ID]
         );
+
+        // Update driver balance
+        await db.query(
+            "UPDATE Driver SET balance = ? WHERE devID = ?",
+            [driverNewBalance, driverId]
+        );
+
+        // Update order details
+        const payStatus = (NetTotal1 === 0 || balance1 === 0) ? "Settled" : "N-Settled";
+        await db.query(
+            "UPDATE Orders SET balance = ?, advance = ?, orStatus = ?, total = ?, netTotal = ?, delStatus = ?, payStatus = ? WHERE OrID = ?",
+            [balance1, advance1, orderStatus, newTotal, NetTotal1, deliveryStatus, payStatus, orderId]
+        );
+
+        // Update delivery details
+        if (dv_id) {
+            await db.query(
+                "UPDATE delivery SET delivery_Date = ?, status = ? WHERE dv_id = ?",
+                [deliveryDate, deliveryStatus, dv_id]
+            );
+        }
+
+        // Process returned items
+        if (returnedItems && Array.isArray(returnedItems)) {
+            for (const item of returnedItems) {
+                if (!item.itemId || !item.stockId) continue;
+
+                await db.query(
+                    "UPDATE m_s_r_detail SET status = ? WHERE I_Id = ? AND stock_Id = ?",
+                    [item.status, item.itemId, item.stockId]
+                );
+
+                const [srdData] = await db.query(
+                    "SELECT srd_Id FROM m_s_r_detail WHERE I_Id = ? AND stock_Id = ?",
+                    [item.itemId, item.stockId]
+                );
+                const srdId = srdData?.[0]?.srd_Id || null;
 
-        // Update Sales Team Record
-        await db.query("UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?", [receivedPayment, stID]);
+                if (srdId) {
+                    await db.query(
+                        "UPDATE issued_items SET status = ? WHERE srd_Id = ? AND orID = ?",
+                        [item.status, srdId, orderId]
+                    );
+                }
+            }
+        }
 
-        // Insert Payment Record
-        await db.query("INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())", [orderid, receivedPayment]);
+        // update balance
+        await db.query(
+            "UPDATE delivery_note_orders SET balance = ? WHERE orID = ?",
+            [balance1, orderId]
+        );
 
-        // Update Driver Balance
-        await db.query("UPDATE driver SET balance = balance + ? WHERE devID = ?", [DrivBalance, dId]);
+        // Insert payment record
+        await db.query(
+            "INSERT INTO Payment (orID, amount, dateTime) VALUES (?, ?, NOW())",
+            [orderId, receivedPayment]
+        );
 
-        // Update Customer Credit Balance
-        await db.query("UPDATE Customer SET credit = ? WHERE c_ID = ?", [creditBalance, cid]);
+        // Update sales team records
+        if (orderStatus !== "Returned" && orderStatus !== "Cancelled") {
+            await db.query(
+                "UPDATE sales_team SET totalIssued = totalIssued + ? WHERE stID = ?",
+                [receivedPayment, stID]
+            );
+        }
 
-        // Update delivery_note_order Balance
-        await db.query("UPDATE delivery_note_orders SET balance = ? WHERE orID = ?", [balance, orderid]);
+        // Insert into return or canceled orders
+        const reasonTable = orderStatus === "Returned" ? "return_orders" : "canceled_orders";
+        await db.query(
+            `INSERT INTO ${reasonTable} (orID, detail) VALUES (?, ?)`,
+            [orID, reason]
+        );
 
         res.json({ success: true, message: "Payment processed successfully." });
 
@@ -4398,7 +4446,6 @@
         return res.status(500).json({ message: "Error checking delivery availability" });
     }
 });
-
 // Function to generate new ida
 const generateNewId = async (table, column, prefix) => {
     const [rows] = await db.query(`SELECT ${column} FROM ${table} ORDER BY ${column} DESC LIMIT 1`);
